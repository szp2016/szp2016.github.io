<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Next主题开启文章分享功能及去除图片上的分享按钮]]></title>
    <url>%2FHexo%2F2019062712%2F</url>
    <content type="text"><![CDATA[Hexo的Next主题中已经集成了文章分享功能，我们只需要clone下github上的分享插件，并修改Next主题配置文件就可以实现文章的分享功能。具体操作如下。 配置Next主题配置文件打开主题配置文件检索baidushare配置如下： 12345678910111213141516171819baidushare: type: slideneedmoreshare2: enable: true postbottom: enable: true options: iconStyle: true boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 下载文章分享所需插件配置文件中已经给出了文章分享所需插件的github仓库地址，即 https://github.com/theme-next/theme-next-needmoreshare2仓库中也给出了使用方法，即首先通过命令行进入themes/next主题目录下，然后将插件clone下来： 12$ cd themes/next$ git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 后期需要更新的话就是通过以下命令： 12$ cd themes/next/source/lib/needsharebutton$ git pull 至此，我们就可以在文章的尾部看到分享文章的按钮了。但是当我把鼠标放在文章中的图片上时，发现图片的右上角也加上了一排分享的按钮，经过分析，找到了添加分享的代码，将其注释一下就大功告成了，实现清清爽爽的页面。找到路径为themes\next\layout_partials\share\baidushare.swig的文件，将代码中的image注释掉。大约在26-30行，代表设置分享按钮在文章底部时的效果；42-46行，代表设置文章分享按钮在侧边时的效果。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;script&gt; window._bd_share_config = &#123; "common": &#123; "bdText": "", "bdMini": "2", "bdMiniList": false, "bdPic": "" &#125;, "share": &#123; "bdSize": "16", "bdStyle": "0" &#125;, // "image": &#123; // "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"], // "viewText": "分享到：", // "viewSize": "16" // &#125; &#125; &lt;/script&gt;&#123;% elif theme.baidushare.type === "slide" %&#125; &lt;script&gt; window._bd_share_config = &#123; "common": &#123; "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "" &#125;, // "image": &#123; // "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"], // "viewText": "分享到：", // "viewSize": "16" // &#125;, "slide": &#123; "bdImg": "5", "bdPos": "left", "bdTop": "100" &#125; &#125; &lt;/script&gt; 注释掉以后执行Hexo g重新生成页面（记得cd .. 退回到Hexo博客的根目录欧），就可以看到图片上已经没有分享按钮了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Git关联Github]]></title>
    <url>%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F2019062616%2F</url>
    <content type="text"><![CDATA[本地git关联github1.输入你的github注册邮箱,生成本地ssh key $ ssh-keygen -t rsa -C “your_email@youremail.com“ 2.然后成功后会在User文件夹对应的用户下创建.ssh文件夹，其中有一个id_rsa.pub文件，我们复制其中的key,进入 Account Settings（账户配置），左边选择SSH and GPG Keys选项。其中的title随便填，下面的粘贴在你电脑上生成的key。 3.验证是否绑定本地成功，在git-bash中验证，输入指令： $ ssh -T git@github.com 如果第一次执行该指令，则会提示是否continue继续，如果我们输入yes就会看到成功信息： 4.由于GitHub每次执行commit操作时，都会记录username和email，下面进行设置： $ git config –global user.name “name”//你的GitHub登陆名$ git config –global user.email “123@163.com“//你的GitHub注册邮箱 5.在github上新建一个仓库，并添加一个README.md文件，并pull到本地： $ git pull “仓库的ssh链接” 6.常用git命令 git init //把这个目录变成Git仓库git add README.md //文件添加到仓库git add . //不但可以跟单一文件，还可以跟通配符，添加当前目录下所有文件git commit -m “first commit” //把文件提交到本地仓库git remote add origin git@github.com:yourname/youremail.git //关联远程仓库git push -u origin master //上传到远程仓库]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堪比华为还详细的编解码插件线下开发教程]]></title>
    <url>%2F%E7%89%A9%E8%81%94%E7%BD%91%2F%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E4%B9%A6%E5%86%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编解码概述书写编解码插件之前首先需要书写Profile文件，定义如下。 Profile文件用于描述一款设备的能力特性。IOT平台通过解析Profile文件，获取该设备支持的服务（通信协议里面的一条完整报文）、属性（报文中的一个字段）、命令（报文中的一个字段）等信息。 IOT平台通过编解码插件，对NB设备上报的数据和下发给NB设备的命令进行格式转换，即将设备上报的16进制格式的报文转换成json，json数据的具体属性名称将由Profile文件来确定。 前期准备知识储备熟悉javase基础编程，maven项目管理工具基本命令，jackson类库。 开发工具Eclipse，jdk1.8，maven，NB设备通信协议。 编解码结构解析Profile结构Profile文件是一个深度为四级的文件夹如图3‑4所示。 红色方框中为第一级目录，目录名称为当前项目的名称，命名规则为：设备类型-厂商ID-设备型号，例如WellMonitor_Chinastar_CSiTWLM05，对应图3‑4功能结构中的Product模块。 绿色方框中为第二级目录，包含两个文件夹profile和service。profile文件夹下放置一个devicetype-capability.json，被用来描述一款设备的能力特征，包括设备类型、厂商、型号、协议类型以及提供的服务类型。相当于对当前整个Profile项目信息的一个概述。service文件夹下则包含设备具备的服务能力，每个服务具备的属性、命令以及命令的参数，对应图3‑4中Service模块。 蓝色方框中代表三级目录，代表具体的服务，每个服务中又包含了属性和命令，属性用于描述设备上报数据，命令用于下发指令给设备，分别对应图3‑4中的Property模块和Command模块。 此外只有红色与蓝色方框中文件的命名可以改动，其他名称固定不变。 例如图2‑1service中包含了WellWaterCommand代表井盖+水位设备所有的下行命令；WellWaterDeviceInfo代表该设备上报的设备信息；WellWaterTiming代表该设备定时上报的信息，共计三个服务。关于如何根据设备的通信协议划分服务，将在第三章中详细介绍。media/4e8ad1d840e65bfc32b745a7004fb776.png 图2‑1 Profile文件结构 图2‑2 Profile功能结构 编解码插件结构编解码插件使用java开发且jdk版本必须为1.8，maven进行项目管理，建议使用eclipse开发工具。其工程目录结构如图3‑4所示。工程的命名建议和Profile项目相同，即采用：设备类型-厂商ID-设备型号的格式。其余包名类名无需更改，即使用华为提供的名称。 其中下行数据编码表示该类将平台下发的json格式的命令转化为字节数组。 上行数据解码则表示该类将设备上报的字节数组转化为json格式数据。 主类则负责调用下行数据编码或者上行数据解码。 工具类中包含了不同数据类型之间转换的方法。 图2‑3 编解码插件工程结构 编解码插件开发Profile开发新建工程新建名称为：设备类型-厂商ID-设备型号的文件夹，例如WellMonitor_Chinastar_CSiTWLM05，打开该文件夹新建profile和service两个子文件夹，如图3‑4所示。注意profile和service这两个文件夹名称是固定不变的。 图3‑1 Profile文件夹 创建概述文件打开profile文件夹新建devicetype-capability.json文件，编辑该json文件如图3‑4所示。其中每个字段所代表的含义如图3‑4所示。serviceTypeCapabilitiesJson数组包含了该Profile文件所有的服务模块，即每增加一个service都需要在这个数组中添加一个对应的json对象。例如Chinstar公司采用CoAP协议，设备型号为CSiTWLM05的井盖设备包含三个服务（功能）模块，井盖命令、井盖开机信息，井盖定时上报信息。 Service划分关于一个设备service的划分，可以采用根据设备通信协议中上报报文的功能码进行划分的方法，即协议中一条上报报文对应一个service（通常一条报文占用一个功能码）。 Service划分步骤： 将通信协议中的报文区分为上行数据和下行数据两类。 将下行数据（命令）写在一个service里面。 将上行数据根据功能码的不同，分成若干个不同的service。 图3‑2 Profile概述文件 图3‑3 Profile文件字段含义 创建service打开第二级目录的service文件夹，根据步骤二devicetype-capability.json文件中serviceTypeCapabilities数组中定义的service创建对应的文件夹，文件夹名称为serviceId对应的值。每个文件夹下分别创建profile文件夹，profile文件夹下创建servicetype-capability.json文件，用来描述具体服务的功能，如图3‑4所示。 图3‑4 service文件结构 接下来编写每个service对应的servicetype-capability.json，如图3‑4所示的Profile，将井盖水位设备的所有命令下发模块单独写在了一个service中，即WellWaterCommand模块；将设备的上报数据信息按照通信协议中每个报文的功能码区分为不同的service，即WellWaterDeviceInfo（开机信息）模块与WellWaterTiming（定时上报）模块。 编写下行service下行命令在service中的书写格式如图3‑5所示。Commands数组里面存放若干个命令对象，每个命令对象包含CommandName命令的名称和paras命令携带的参数数组，以及responses命令回应数组。paras数组里面包含若干个参数对象。参数对象包含paraName等一系列属性。这每一个参数对象都对应通信协议报文中的一个属性。serviceType的值一定要与当前服务文件夹名称保持一致。 图3‑5 命令service 编写上行service上行属性service比命令service要简单，properties数组中存放的是设备上报上来的数据，每一个json对象对应通信协议报文中的一个属性。propertyName的值可以随意定义，dataType的值如不能根据通信协议中的默认参数值明显的判断该属性的数据类型，应找相关人员确认，否则解析将会出现数据错误。 打包Profile将WellMonitor_Chinastar_CSiTWLM05文件夹下的profile和service文件打包为zip格式，命名为WellMonitor_Chinastar_CSiTWLM05，并且压缩包内不能包含WellMonitor_Chinastar_CSiTWLM05文件夹这一层目录。 编解码开发使用eclipse配置本地maven仓库，并导入华为提供的demo工程。 修改pom.xml中的&lt;artifactId&gt;XXX&lt;/artifactId&gt;和&lt;Bundle-SymbolicName&gt;XXX&lt;/Bundle-SymbolicName&gt;命名规范：设备类型-厂商ID-设备型号，与Profile文件保持一致。如图3‑6、图3‑7所示。 图3‑6 pom修改厂商名称 图3‑7 pom修改厂商名称 修改ProtocolAdapterImpl.java中的厂商名称与设备型号，注意与Profile保持一致。如图3‑8所示。 图3‑8 修改Protocol文件 编写下行编码数据下行编码流程如图3‑9所示，通过获取OC平台发送过来的json数据，首先根据serviceId将对应数据保存到全局变量中，然后调用toByte方法，将各种类型的数据装换为16进制的比特数组。拼装成一条完整的报文并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 图3‑9 数据下行编码流程图 编写上行解码数据上行解码流程如图3‑10所示。通过获取OC平台发送过来的16进制比特数组格式数据，首先根据比特数组中的功能码（功能码在数据哪个位置，请从通信协议中查看），将不同服务对应的不同数据，根据通信协议将byte类型的属性转换为所需类型，保存到全局变量中，然后调用toJsonNode方法，拼装成一个Json对象并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 图3‑10 数据上行解码流程图 打包编解码打包编解码，即将该maven工程打包成jar文件。检查pom.xml中的&lt;packaging&gt;bundle&lt;/packaging&gt;值是否为bundle，不能为jar。以eclipse为例，在工程上右键选择RunAs然后选择Maven build…如图3‑11所示。 图3‑11 Mavenbuild 在Goals中输入clean package点击Run按钮，如图3‑12所示。 图3‑12 Mavenpackage 等待控制台出现BUILDSUCCESS，即可在当前项目的target目录下找到打包好的jar文件，如图3‑13所示，打包编解码完成。 图3‑13 Build 附录 点击显/隐内容 上行代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557package com.thrid.party.codec.demo;import java.util.Arrays;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ArrayNode;import com.fasterxml.jackson.databind.node.ObjectNode;public class ReportProcess &#123;// private String identifier;private String msgType = &quot;deviceReq&quot;;private int hasMore = 0;private int errcode = 0;// 在报文中表示报文类型的字段private byte bFunctionCode;// 开机信息功能码private static final byte DEVICE_POWER_ON = 0x01;// 数据上报功能码private static final byte DEVICE_DATA_REPORT = 0x02;// 应答报文功能码private static final byte DEVICE_REPLY = (byte) 0xAA;// 无后续数据private static final int NO_MORE = 0;private static final String REQUEST =&quot;deviceReq&quot;;private static final String RESPONSE =&quot;deviceRsp&quot;;private int identifier;private int protocolVersion;// 终端类型默认为12private int deviceType;private int iDeviceState = 0;// 终端压力阈值（默认未0），上行数据会对这个值进行覆盖private int distanceAlarmThreshold = 0;;// 终端定时上报时间 ，上行数据会对这个值进行覆盖private int iHeartBeatTime = 0;// 终端报警间隔时间，上行数据会对这个值进行覆盖private int iAlarmReportInterval = 0;private int iSampleInterval = 0;// 终端硬件版本，上行数据会对这个值进行覆盖private int iVersionHW = 1;// 终端软件版本，，上行数据会对这个值进行覆盖private int iVersionFW = 1;// 终端SN号，上行数据会对这个值进行覆盖private int iDeviceSN = 1;private int iNbiotState = 0;// 电池状态，上行数据会对这个值进行覆盖private int iBatteryState = 0;// 云端应答状态，上行数据会对这个值进行覆盖private int iAckState = 0;private int iGuardState = 0;// 报警状态 （默认为0不报警），在定时上报中会对这个值进行覆盖private int iAlarmState = 0;// 当前压力，在定时上报中会对这个值进行覆盖private int iCurPValue = 0;// 当前角度，在定时上报中会对这个值进行覆盖private int iBatteryVoltage = 3600;private int iBatteryCap;// 信号强度，在定时上报中会对这个值进行覆盖private int iSignalStrength = 0;// 信号覆盖等级，在定时上报中会对这个值进行覆盖private int iSignalECL = 0;// 信噪比，在定时上报中会对这个值进行覆盖private int iSignalSNR = 0;// 小区所在Id,在定时上报中会对这个值进行覆盖private int iCellId = 0;// 小区所在得PCI,在定时上报中会对这个值进行覆盖private int iSignalPCI = 0;// 温度，在定时上报中会对这个值进行覆盖// private int iTemperature = 0;// 终端回应设置信息时上发的错误码private int iResult = 0;private int mid = 0;private int curTilt = 0;private int bgTilt = 0;private int gasDensity = 0;private int alarmThreshold = 0;private int waterStatus = 0;private int deviceState = 0;private String strDevPostfix;private String imei;private String imsi;/\*\*\* \@param binaryData 设备发送给平台coap报文\* \@return\*/public ReportProcess(byte[] binaryData) &#123;binaryData = Utilty.getInstance().positionFormat(binaryData);protocolVersion = binaryData[0];bFunctionCode = binaryData[1];identifier = Utilty.getInstance().bytes2Int(binaryData, 2, 2);mid = Utilty.getInstance().bytes2Int(binaryData, 4, 2);Utilty.getInstance().mid = mid;Utilty.getInstance().functioncode = bFunctionCode;System.out.println(&quot;dingmingdong\\n&quot;);System.out.println(Utilty.getInstance().mid);System.out.println(identifier);if (bFunctionCode == DEVICE_POWER_ON) &#123;msgType = REQUEST;hasMore = NO_MORE;iDeviceSN = Utilty.getInstance().bytes2Int(binaryData,8, 4);deviceType = binaryData[12];// iGuardState = binaryData[5];iVersionHW = binaryData[13];iVersionFW = Utilty.getInstance().bytes2Int(binaryData,14, 4);//strDevPostfix = new String(binaryData, 14, 16);//iDeviceState = Utilty.getInstance().bytes2Int(binaryData,30, 2);iHeartBeatTime = Utilty.getInstance().bytes2Int(binaryData, 20, 2);iAlarmReportInterval = Utilty.getInstance().bytes2Int(binaryData, 22, 2);iSampleInterval = Utilty.getInstance().bytes2Int(binaryData, 24, 2);imei = new String(binaryData, 26, 16);imsi = new String(binaryData, 42, 16);alarmThreshold = Utilty.getInstance().bytes2Int(binaryData, 58, 2);//binArray用于存放状态码的二进制数字，由于binaryData[31]转换的二进制数组中目前未携带有用信息，不做解析// int[] binArray = Utilty.getInstance().byte2Binary(binaryData[30]);// iBatteryState = binArray[0];//iAckState = binArray[1];// iNbiotState = binArray[2];// iGuardState = binArray[3];// iAlarmState = binArray[4];// iDeviceState = binArray[5];// iBlueteethState = binArray[6];// strModuleVersion = new String(binaryData, 21, 20);&#125; else if( bFunctionCode == DEVICE_DATA_REPORT )&#123;msgType = REQUEST;hasMore = NO_MORE;iDeviceSN = Utilty.getInstance().bytes2Int(binaryData,8, 4);deviceState = Utilty.getInstance().bytes2Int(binaryData,12, 2);// iBatteryVoltage = Utilty.getInstance().bytes2Int(binaryData, 4, 2);iBatteryCap = Utilty.getInstance().bytes2Int(binaryData, 14, 1);iSignalStrength = Utilty.getInstance().bytes2Int(binaryData, 16, 4);iSignalECL = binaryData[20];iSignalSNR = binaryData[21];iCellId = Utilty.getInstance().bytes2Int(binaryData, 22, 4);iSignalPCI = Utilty.getInstance().bytes2Int(binaryData, 26, 2);bgTilt = Utilty.getInstance().bytes2Int(binaryData, 28, 2);curTilt = Utilty.getInstance().bytes2Int(binaryData, 30, 2);gasDensity = Utilty.getInstance().bytes2Int(binaryData, 32, 2);waterStatus = Utilty.getInstance().bytes2Int(binaryData, 34, 2);&#125;else if (bFunctionCode == DEVICE_REPLY) &#123;msgType = RESPONSE;// 在华为的API中规定 ： errcode 为0表示成功，1表示失败 ；但下位机协议中规定错误码为0无错误，1超范围，2检验错误；在profile文件中终端的应答应当包含一个int型的result参数,// 为了避免数据损失，在这里将终端的错误码放在result中，而errcode按照华为的API规定，只要下位机的错误码不为零，就认为失败，即在error中装入1.errcode = binaryData[8]==0?0:1;iResult = binaryData[8];&#125; else &#123;return;&#125;&#125;public ObjectNode toJsonNode() &#123;try &#123;//组装body体ObjectMapper mapper = new ObjectMapper();ObjectNode root = mapper.createObjectNode();String s = Integer.toString(this.identifier);root.put(&quot;identifier&quot;, s);System.out.println(s);root.put(&quot;msgType&quot;, this.msgType);//根据msgType字段组装消息体if (this.msgType.equals(REQUEST) &amp;&amp; bFunctionCode == DEVICE_POWER_ON) &#123;root.put(&quot;hasMore&quot;, this.hasMore);ArrayNode arrynode = mapper.createArrayNode();// serviceId = Basic 数据组装ObjectNode BasicNode = mapper.createObjectNode();BasicNode.put(&quot;serviceId&quot;, &quot;Basic&quot;);ObjectNode BasicData = mapper.createObjectNode();BasicData.put(&quot;heartBeatTime&quot;, this.iHeartBeatTime);BasicData.put(&quot;alarmReportInterval&quot;, this.iAlarmReportInterval);BasicData.put(&quot;sampleInterval&quot;, this.iSampleInterval);BasicData.put(&quot;mid&quot;, this.mid);//hydrantBasicData.put(&quot;tiltAlarmThreshold&quot;, this.iTiltAlarmThreshold);BasicNode.put(&quot;serviceData&quot;,BasicData);arrynode.add(BasicNode);// serviceId = Tilt 数据组装ObjectNode TiltNode = mapper.createObjectNode();TiltNode.put(&quot;serviceId&quot;, &quot;Tilt&quot;);ObjectNode TiltData = mapper.createObjectNode();TiltData.put(&quot;alarmThreshold&quot;, this.alarmThreshold);//hydrantBasicData.put(&quot;tiltAlarmThreshold&quot;, this.iTiltAlarmThreshold);TiltNode.put(&quot;serviceData&quot;,TiltData);arrynode.add(TiltNode);// serviceId = DeviceInfo 数据组装ObjectNode deviceInfoNode = mapper.createObjectNode();deviceInfoNode.put(&quot;serviceId&quot;, &quot;DeviceInfo&quot;);ObjectNode deviceInfoData = mapper.createObjectNode();deviceInfoData.put(&quot;deviceType&quot;, this.deviceType);deviceInfoData.put(&quot;versionHW&quot;, this.iVersionHW);deviceInfoData.put(&quot;versionFW&quot;, this.iVersionFW);deviceInfoData.put(&quot;deviceSN&quot;, this.iDeviceSN);deviceInfoData.put(&quot;imei&quot;, this.imei);deviceInfoData.put(&quot;imsi&quot;, this.imsi);deviceInfoData.put(&quot;deviceID&quot;, this.identifier);deviceInfoData.put(&quot;protocolVersion&quot;, this.protocolVersion);//deviceInfoData.put(&quot;moduleVersion&quot;, this.strModuleVersion);deviceInfoNode.put(&quot;serviceData&quot;,deviceInfoData);arrynode.add(deviceInfoNode);root.put(&quot;data&quot;, arrynode);&#125; else if(this.msgType.equals(REQUEST) &amp;&amp; bFunctionCode == DEVICE_DATA_REPORT)&#123;root.put(&quot;hasMore&quot;, this.hasMore);ArrayNode arrynode = mapper.createArrayNode();// serviceId = Basic 数据组装ObjectNode BasicNode = mapper.createObjectNode();BasicNode.put(&quot;serviceId&quot;, &quot;Basic&quot;);ObjectNode BasicData = mapper.createObjectNode();//BasicData.put(&quot;batteryVoltage&quot;, this.iBatteryVoltage);BasicData.put(&quot;batteryLevel&quot;,this.iBatteryCap);BasicData.put(&quot;deviceState&quot;, this.deviceState);BasicData.put(&quot;mid&quot;, this.mid);BasicNode.put(&quot;serviceData&quot;,BasicData);arrynode.add(BasicNode);// serviceId = Connectivity 数据组装ObjectNode connectivityNode = mapper.createObjectNode();ObjectNode connectivityData = mapper.createObjectNode();connectivityData.put(&quot;signalStrength&quot;, this.iSignalStrength);connectivityData.put(&quot;cellId&quot;, this.iCellId);connectivityData.put(&quot;signalECL&quot;, this.iSignalECL);connectivityData.put(&quot;signalPCI&quot;, this.iSignalPCI);connectivityData.put(&quot;signalSNR&quot;, this.iSignalSNR);connectivityNode.put(&quot;serviceId&quot;, &quot;Connectivity&quot;);connectivityNode.put(&quot;serviceData&quot;,connectivityData);arrynode.add(connectivityNode);// serviceId = Tilt 数据组装ObjectNode tiltNode = mapper.createObjectNode();ObjectNode tiltData = mapper.createObjectNode();tiltData.put(&quot;curTilt&quot;, this.curTilt);tiltData.put(&quot;bgTilt&quot;, this.bgTilt);tiltData.put(&quot;gasDensity&quot;, this.gasDensity);tiltData.put(&quot;waterStatus&quot;, this.waterStatus);tiltNode.put(&quot;serviceId&quot;, &quot;Tilt&quot;);tiltNode.put(&quot;serviceData&quot;,tiltData);arrynode.add(tiltNode);// serviceId = DeviceInfo 数据组装ObjectNode deviceInfoNode = mapper.createObjectNode();deviceInfoNode.put(&quot;serviceId&quot;, &quot;DeviceInfo&quot;);ObjectNode deviceInfoData = mapper.createObjectNode();// deviceInfoData.put(&quot;deviceType&quot;, this.deviceType);// deviceInfoData.put(&quot;versionHW&quot;, this.iVersionHW);// deviceInfoData.put(&quot;versionFW&quot;, this.iVersionFW);deviceInfoData.put(&quot;deviceSN&quot;, this.iDeviceSN);// deviceInfoData.put(&quot;imei&quot;, this.imei);// deviceInfoData.put(&quot;imsi&quot;, this.imsi);deviceInfoData.put(&quot;deviceID&quot;, this.identifier);deviceInfoData.put(&quot;protocolVersion&quot;, this.protocolVersion);//deviceInfoData.put(&quot;moduleVersion&quot;, this.strModuleVersion);deviceInfoNode.put(&quot;serviceData&quot;,deviceInfoData);arrynode.add(deviceInfoNode);// serviceId = DeviceState 数据组装// ObjectNode deviceStateNode = mapper.createObjectNode();// ObjectNode deviceStateData = mapper.createObjectNode();//deviceStateData.put(&quot;guardState&quot;, this.iGuardState);//deviceStateData.put(&quot;alarmState&quot;, this.iAlarmState);//deviceStateData.put(&quot;moduleState&quot;, this.iNbiotState);//deviceStateData.put(&quot;batteryState&quot;, this.iBatteryState);//deviceStateData.put(&quot;ackState&quot;, this.iAckState);//deviceStateNode.put(&quot;serviceId&quot;, &quot;DeviceState&quot;);//deviceStateNode.put(&quot;serviceData&quot;,deviceStateData);//arrynode.add(deviceStateNode);// serviceId = Temperature 数据组装// ObjectNode temperatureNode = mapper.createObjectNode();// ObjectNode temperatureData = mapper.createObjectNode();// temperatureData.put(&quot;temperature&quot;, this.iTemperature);// temperatureNode.put(&quot;serviceId&quot;, &quot;Temperature&quot;);// temperatureNode.put(&quot;serviceData&quot;,temperatureData);// arrynode.add(temperatureNode);root.put(&quot;data&quot;, arrynode);&#125;else &#123;root.put(&quot;mid&quot;, this.mid);root.put(&quot;errcode&quot;, this.errcode);//组装body体，只能为ObjectNode对象ObjectNode body = mapper.createObjectNode();body.put(&quot;result&quot;, iResult);root.put(&quot;body&quot;, body);&#125;return root;&#125; catch (Exception e) &#123;e.printStackTrace();return null;&#125;&#125;&#125; 下行数据代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725package com.thrid.party.codec.demo;import java.util.Arrays;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.node.ObjectNode;public class CmdProcess &#123;private String identifier = &quot;0&quot;;private int intIdentifier = 0;private String msgType = &quot;deviceReq&quot;;private String serviceId = &quot;Brightness&quot;;private int hasMore = 0;private static int mid = 0;private int errcode = 0;private JsonNode paras;private String cmd = &quot;REREAD&quot;;// 云端回应private static final byte B_CMD_RESPONSE = (byte) 0xAA;// 配置信息private static final byte B_TO_CONFIGURATION = 0x03;// 复位命令private static final byte B_TO_RESET = 0x04;// 布防/撤防private static final byte B_TO_GUARD_OR_WITHDRAW = 0x05;// 忽略本次报警private static final byte B_TO_IGNORE = 0x06;// 重新读取开机信息private static final byte B_TO_REREAD = 0x07;private static final byte B_TO_FACTORYDEFAULT = 0x09;private static final byte B_TO_SAMPLE_BGTILT_RSP = 10;// 在报文中表示报文类型的字段private byte bFunctionCode;// 在报文中表示信息长度的字段private byte dataLength;// 将要配置的新IDprivate int iNewId;// 上报时间private int iHeartBeatTime;// 报警间隔private int iAlarmReportInterval;private int iSampleInterval;private byte protocolVersion = 1;// IP设置private int iAddressIP;// 端口号设置private int iAddressPort;// 压力报警阈值private int distanceAlarmThreshold;private int reportmid;private int iPressureAlarmLowThreshold;private int iPressureAlarmUpDiff;private int iPressureAlarmLowDiff;// 倾斜角报警阈值// private int iTiltAlarmThreshold;// 在命令为GUARD_OR_WITHDRAW时是要布防还是撤防： 1表示布防，0表示撤防private byte bGuardOrWithdraw = 1;// 用于存储平台自动应答时返回的request字段，该字段即设备的上行数据byte[] deviceRequest;public CmdProcess() &#123;&#125;public CmdProcess(ObjectNode input) &#123;try &#123;try &#123;this.identifier = input.get(&quot;identifier&quot;).asText();&#125; catch (Exception e) &#123;&#125;mid = mid + 1;this.msgType = input.get(&quot;msgType&quot;).asText();// this.mid = input.get(&quot;mid&quot;).asInt();//未使用mid在此处不能放出来，否则会造成程序异常if (msgType.equals(&quot;cloudRsp&quot;)) &#123;this.errcode = input.get(&quot;errcode&quot;).asInt();deviceRequest = input.get(&quot;request&quot;).binaryValue();byte[] identifierBytes = &#123;deviceRequest[3],deviceRequest[2]&#125;;intIdentifier = Utilty.getInstance().bytes2Int(identifierBytes, 0, 2);byte[] midBytes = &#123;deviceRequest[5],deviceRequest[4]&#125;;reportmid = Utilty.getInstance().bytes2Int(midBytes, 0, 2);bFunctionCode = B_CMD_RESPONSE;dataLength = 0x01;&#125; else &#123;this.cmd = input.get(&quot;cmd&quot;).asText();switch (this.cmd) &#123;case &quot;CONFIGURATION&quot;:bFunctionCode = B_TO_CONFIGURATION;dataLength = 22;this.paras = input.get(&quot;paras&quot;);iNewId = this.paras.get(&quot;newId&quot;).asInt();iHeartBeatTime = this.paras.get(&quot;heartBeatTime&quot;).asInt();iAlarmReportInterval = this.paras.get(&quot;alarmReportInterval&quot;).asInt();iSampleInterval = this.paras.get(&quot;sampleInterval&quot;).asInt();iAddressIP = this.paras.get(&quot;addressIP&quot;).asInt();iAddressPort = this.paras.get(&quot;addressPort&quot;).asInt();distanceAlarmThreshold = this.paras.get(&quot;distanceAlarmThreshold&quot;).asInt();//iPressureAlarmLowThreshold =this.paras.get(&quot;pressureAlarmLowThreshold&quot;).asInt();//iPressureAlarmUpDiff = this.paras.get(&quot;pressureAlarmUpDiff&quot;).asInt();//iPressureAlarmLowDiff = this.paras.get(&quot;pressureAlarmLowDiff&quot;).asInt();//iTiltAlarmThreshold = this.paras.get(&quot;tiltAlarmThreshold&quot;).asInt();break;case &quot;RESET&quot;:bFunctionCode = B_TO_RESET;dataLength = 0x00;break;case &quot;SAMPLE_BGTILT_RSP&quot;:bFunctionCode = B_TO_SAMPLE_BGTILT_RSP;dataLength = 0x00;break;case &quot;GUARD_OR_WITHDRAW&quot;:bFunctionCode = B_TO_GUARD_OR_WITHDRAW;dataLength = 0x01;this.paras = input.get(&quot;paras&quot;);bGuardOrWithdraw = (byte) this.paras.get(&quot;guardOrWithdraw&quot;).asInt();break;case &quot;IGNORE&quot;:bFunctionCode = B_TO_IGNORE;dataLength = 0x00;break;case &quot;REREAD&quot;:bFunctionCode = B_TO_REREAD;dataLength = 0x00;break;case &quot;FACTORYDEFAULT&quot;:bFunctionCode = B_TO_FACTORYDEFAULT;dataLength = 0x00;break;default:break;&#125;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;public byte[] toByte() &#123;try &#123;if (this.msgType.equals(&quot;cloudReq&quot;)) &#123;byte[] bytesRead = null;int idid = 0;try &#123;idid = Integer.parseInt(this.identifier);&#125; catch (NumberFormatException e) &#123;e.printStackTrace();&#125;switch (this.cmd) &#123;case &quot;CONFIGURATION&quot;:&#123;//iNewId = this.paras.get(&quot;newId&quot;).asInt();//iHeartBeatTime = this.paras.get(&quot;heartBeatTime&quot;).asInt();//iAlarmReportInterval = this.paras.get(&quot;alarmReportInterval&quot;).asInt();//iAddressIP = this.paras.get(&quot;addressIP&quot;).asInt();//iAddressPort = this.paras.get(&quot;addressPort&quot;).asInt();//iPressureAlarmThreshold = this.paras.get(&quot;pressureAlarmThreshold&quot;).asInt();//iTiltAlarmThreshold = this.paras.get(&quot;tiltAlarmThreshold&quot;).asInt();dataLength = 18;bytesRead= new byte[28];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;//byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNewId = Utilty.getInstance().int2Bytes(this.iNewId, 2);bytesRead[8] = bytesNewId[1];bytesRead[9] = bytesNewId[0];byte[] bytesHeartBeatTime = Utilty.getInstance().int2Bytes(this.iHeartBeatTime,2);bytesRead[10] = bytesHeartBeatTime[1];bytesRead[11] = bytesHeartBeatTime[0];byte[] bytesAlarmReportInterval =Utilty.getInstance().int2Bytes(this.iAlarmReportInterval, 2);bytesRead[12] = bytesAlarmReportInterval[1];bytesRead[13] = bytesAlarmReportInterval[0];byte[] bytesSampleInterval =Utilty.getInstance().int2Bytes(this.iSampleInterval, 2);bytesRead[14] = bytesSampleInterval[1];bytesRead[15] = bytesSampleInterval[0];byte[] bytesAddressIP = Utilty.getInstance().int2Bytes(this.iAddressIP, 4);bytesRead[16] = bytesAddressIP[3];bytesRead[17] = bytesAddressIP[2];bytesRead[18] = bytesAddressIP[1];bytesRead[19] = bytesAddressIP[0];byte[] bytesAddressPort = Utilty.getInstance().int2Bytes(this.iAddressPort, 2);bytesRead[20] = bytesAddressPort[1];bytesRead[21] = bytesAddressPort[0];byte[] bytesAlarmThreshold =Utilty.getInstance().int2Bytes(this.distanceAlarmThreshold, 2);bytesRead[22] = bytesAlarmThreshold[1];bytesRead[23] = bytesAlarmThreshold[0];bytesRead[24] = 0;bytesRead[25] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[26] = bytesCRC[1];bytesRead[27] = bytesCRC[0];break;&#125;case &quot;RESET&quot;:&#123;bFunctionCode = B_TO_RESET;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;GUARD_OR_WITHDRAW&quot;:&#123;bFunctionCode = B_TO_GUARD_OR_WITHDRAW;bGuardOrWithdraw = (byte) this.paras.get(&quot;guardOrWithdraw&quot;).asInt();dataLength = 0x02;bytesRead= new byte[12];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;bytesRead[8] = bGuardOrWithdraw;bytesRead[9] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[10] = bytesCRC[1];bytesRead[11] = bytesCRC[0];break;&#125;case &quot;IGNORE&quot;:&#123;bFunctionCode = B_TO_IGNORE;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;SAMPLE_BGTILT_RSP&quot;:&#123;bFunctionCode = B_TO_SAMPLE_BGTILT_RSP;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;FACTORYDEFAULT&quot;:&#123;bFunctionCode = B_TO_FACTORYDEFAULT;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;REREAD&quot;:&#123;bFunctionCode = B_TO_REREAD;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;default:break;&#125;return bytesRead;&#125; else if (this.msgType.equals(&quot;cloudRsp&quot;)) &#123;byte[] bytesRead = new byte[12];/\*\*平台对上行数据的自动应答过程中，并不会每次都去调用带参的构造方法（猜测），所以数据的具体组装需要在toByte方法中进行以保证回复及下发的稳定性\*/bFunctionCode = B_CMD_RESPONSE;dataLength = 2;/\*\*在此对捕获的设备命令进行校验，如果无错误，将errcode置为0，若校验错误，将其置为2\*/boolean isValide = false;if(deviceRequest != null)&#123;isValide = Utilty.getInstance().isValid(deviceRequest);&#125;bytesRead= new byte[12];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = B_CMD_RESPONSE;//byte[] bytesId = Utilty.getInstance().int2Bytes(this.intIdentifier, 2);;bytesRead[2] = deviceRequest[2];bytesRead[3] = deviceRequest[3];//byte[] bytesmid = Utilty.getInstance().int2Bytes(this.reportmid, 2);bytesRead[4] = deviceRequest[4];bytesRead[5] = deviceRequest[5];bytesRead[6] = dataLength;bytesRead[7] = 0;bytesRead[8] = 0;//(byte) (isValide?0:2);bytesRead[9] = (byte)Utilty.getInstance().functioncode;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[10] = bytesCRC[1];bytesRead[11] = bytesCRC[0];return bytesRead;&#125;return null;&#125; catch (Exception e) &#123;// TODO: handle exceptione.printStackTrace();return null;&#125;&#125;&#125;]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>OceanConnect</tag>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty组件和设计]]></title>
    <url>%2FNetty%2FNetty%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Netty的组件和设计Channel 接口 在基于Java的网络编程中，其基本的构造是class socket。Netty的Channel接口所提供的api，大大的降低了直接使用Socket类的复杂性。 EventLoop 接口 EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。 一个EventLoopGroup包含一个或者多个EventLoop； 一个EventLoop在它的生命周期内只和一个Thread绑定； 所有由EventLoop处理的 I/O 事件都将在它专有的Thread上被处理； 一个Channel在它的生命周期内只注册于一个EventLoop； 一个EventLoop可能会被分配给一个或多个Channel。 ChannelFuture 接口 Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会 立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了 ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以 便在某个操作完成时（无论是否成功）得到通知。 ChannelHandler 接口 充当了所有 处理入站和出站数据的应用程序逻辑的容器。 ChannelPipeline 接口 ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站 和出站事件流的 API。当 Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。 ChannelPipeline中存放的是ChannelHandler链，一条数据可以经过多个ChannelHandler进行处理，类似拦截器。 引导 Bootstrap 客户端配置 ServerBootstrap 服务端配置 引导一个客户端只需要一个 EventLoopGroup，但是一个 ServerBootstrap则需要两个（也可以是同一个实例）。 因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务 器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传 入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
