<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文件共享与保护]]></title>
    <url>%2Funcategorized%2F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux字符设备驱动程序]]></title>
    <url>%2Funcategorized%2FLinux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[5.4 Linux设备驱动分类Linux系统将设备分为三个类：字符设备、块设备、网络设备，在这三大类中，字符设备相对比较简单，应用程序通过字符设备文件来访问字符设备，本讲主要介绍字符设备，如果对块设备和网络设备感兴趣的话，可以参看相关资料，并对其进行深入了解。 什么是字符设备？字符设备是指只能一个字节一个字节进行读写操作的设备，不能随机读取设备中的某一数据、读取数据要按照先后顺序。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED等。 一般每个字符设备或者块设备都会在/dev目录下对应一个设备文件，并且每个设备文件都必须有主/次设备号，主设备号相同的设备是同类设备，使用同一个驱动程序。 Linux用户层程序通过设备文件来使用驱动程序操作字符设备或块设备。 可以通过 cat /proc/devices 命令查看当前已经加载的设备驱动程序的主设备号。 通过在/dev目录下执行命令 ls -l 可以看到所有设备文件的主设备号和次设备号： 对常见设备文件作如下说明： 点击查看详细内容 /dev/hd[a-t]：IDE设备 /dev/sd[a-z]：SCSI设备 /dev/fd[0-7]：标准软驱 /dev/md[0-31]：软raid设备 /dev/loop[0-7]：本地回环设备 /dev/mem：内存 /dev/null：无限数据接收设备,相当于黑洞 /dev/zero：无限零资源 /dev/tty[0-63]：虚拟终端 /dev/ttyS[0-3]：串口 /dev/lp[0-3]：并口 /dev/console：控制台 /dev/fb[0-31]：framebuffer /dev/cdrom =&gt; /dev/hdc /dev/modem =&gt; /dev/ttyS[0-9] /dev/pilot =&gt; /dev/ttyS[0-9] 如何建立设备文件？建立设备文件有两种方式，一是通过系统调用mknod()，编程中调用该函数可以建立一个新的设备文件名，另外一种就是通过mknod命令，命令的第一个参数为设备文件名，第二个参数为设备类型，比如c表示字符设备，第三、四个参数为设备文件的主设备号和次设备号，比如231和0。主设备号和次设备号合起来唯一的确定一个设备，同一个设备不同类型的主设备号是一样的，次设备号不同，比如一个硬盘的多个分区就有不同的次设备号，通过主设备号就可以把设备文件与驱动程序关联起来。 mknod filename type major minor filename：要创建的设备文件名； type：设备类型，c代表一个字符设备，b代表一个块设备； major：主设备号； minor：次设备号； 如何描述字符设备？Linux内核中抽象出struct cdev结构体来表示一个字符设备，cdev 定义于 &lt;linux/cdev.h&gt; 中其中，其中最关键的是file_operations结构，它是实现字符设备的操作集。 12345678struct cdev &#123; struct kobject kobj; // 内嵌内核对象 struct module *owner; //该字符设备所在的内核模块 const struct file_operations *ops; //文件操作结构体 struct list_head list; //已注册字符设备链表 dev_t dev; //由主、次设备号构成的设备号 unsigned int count;//同一主设备号的次设备号的个数&#125;; Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个系统调用。 123456789101112131415161718struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char *, size_t, loff_t *); ssize_t (*write) (struct file *, const char *, size_t, loff_t *); int (*readdir) (struct file *, void *, filldir_t); unsigned int (*poll) (struct file *, struct poll_table_struct *); int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, struct dentry *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*readv) (struct file *, const struct iovec *, unsigned long,loff_t *); ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *); &#125;; 用户进程利用在对设备文件进行诸如read，write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。 字符设备与文件系统的接口 如图，在Linux内核中，最左边， 使用cdev结构体来描述字符设备;通过其成员dev_t来定义设备号（分为主、次设备号）以确定字符设备的唯一性;通过其成员file_operations来定义字符设备驱动提供给虚拟文件系统VFS的接口函数，如常见的open()、read()、write()等,这些函数真正的操作硬件设备。 在上一个图的基础上我们看这个图，字符设备驱动程序是以内核模块的形式加载到内核中的，首先模块加载函数按静态或者动态方式获取设备号；然后字符设备初始化函数建立cdev与 file_operations之间的连接， 通过注册函数向系统添加一个cdev以完成注册; 模块卸载时与加载对应，要注销cdev，并释放设备号。 在用户程序中，可以通过系统调用open(), read(), write()等调用驱动程序在内核中所实现的这些函数。这样用户态到内核驱动之间的通路就打通了。 编写简单的字符设备驱动程序 如图，编写字符设备驱动分为三大步骤： 驱动的初始化，其中又分为四个步骤，调用相关的函数达到。 实现设备的操作，具体的操作取决于你自己所要实现的功能，这里只列出了基本的操作 驱动的注销，注销就是释放资源。 其中调用的接口函数功能如下： 第1个函数是分配函数，动态申请cdev的内存，给该结构分配内存空间。 第2个函数是初始化函数，初始化cdev的成员，并建立cdev和file_operations之间关联. 第3个函数注册cdev设备对象，也就是把字符设备添加到字符设备表中，就像大家入学时进行注册一样。 第4个函数是注销驱动程序调用，将cdev对象从系统中删除。 第5个函数释放cdev数据结构所占的内存。 设备号的申请和释放一个字符设备或块设备都有一个主设备号和一个次设备号。主设备号用来标识与设备文件相连的驱动程序，用来反映设备类型。次设备号被驱动程序用来辨别操作的是哪个设备，用来区分同类型的设备。注册时申请设备号，注销时释放设备号，就像大家入学是有一个学号，毕业离开时就释放掉这个学号。 用户空间与内核空间数据的传送当我们在用户程序中调用read（）函数时，陷入内核空间，实际上要通过内核的copy_to_user()函数把内核空间缓冲区中的数据拷贝到用户空间的缓冲区，反之，当我们调用write（)函数时，内核通过调用copy_from_user()函数把用户空间的数据拷贝到内核缓冲区。 小结如何具体编写一个字符驱动程序，主要有三个步骤，一是驱动的初始化，二是实现对设备的具体操作，三是注销驱动程序， 在动手实践一节，将给出一个字符设备驱动程序的编写过程以及运行机制。]]></content>
  </entry>
  <entry>
    <title><![CDATA[I/O设备驱动程序]]></title>
    <url>%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FIO%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[5.3 I/O设备驱动程序 什么是设备驱动程序？设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序，其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令，文件系统把这些请求转换为具体要求后，发送给设备控制器，启动设备去执行；反之，它也将由设备控制器发来的信号传送给上层软件。 思考一下为何不同的设备需要不同的设备驱动程序？ 由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种驱动程序。例如，打印机和显示器需要不同的驱动程序。 不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。 设备驱动程序的功能实现I/O进程与设备控制器之间的通信,设备驱动程序应具有以下功能 接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。 例如，将磁盘块号转换为磁盘的盘面、磁道号及扇区号。 检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。 发出I/O命令，如果设备空闲，立即启动I/O设备，完成指定I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。 设备驱动程序的特点设备驱动程序属于低级的系统例程，它与一般的应用程序及系统程序之间有下述明显差异。 驱动程序主要是指在请求I/O的进程与设备控制器之间的一个通信和转换程序。 它将进程的I/O请求经过转换后，传送给控制器；又把控制器中所记录的设备状态和I/O操作完成情况及时的反应给请求I/O的进程。 驱动程序与设备控制器和I/O设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。 例如，可以为相同的多个终端设置一个终端驱动程序，但有时即使是同一类型的设备，由于其生产厂家不同，他们也可能并不完全兼容，此时也需为它们配置不同的驱动程序。 驱动程序与I/O设备所采用的I/O控制方式紧密相关。 常用的I/O控制方式是中断驱动和DMA方式，这两种方式的驱动程序明显不同，后者是按数组方式启动设备及进行中断处理。 由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言编写。目前有很多驱动程序的基本部分，已经固化在ROM中。 驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。例如，网络驱动程序正在处理一个到来的数据包时，另一个数据包可能已经到达。 设备驱动程序的处理过程不同类型的设备应有不同的设备驱动程序，但大体上它们都可以分成两部分： 能够驱动I/O设备工作的驱动程序 设备中断处理程序（处理I/O完成后的工作）。 设备驱动程序的主要任务是启动指定设备。但在启动之前，还必须完成必要的准备工作，如检测设备状态是否为“忙”等。在完成所有的准备工作后，才向设备控制器发送一条启动命令。以下是设备驱动程序的处理过程： 将抽象要求转换为具体要求 由于用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它发出抽象的要求（命令），但这些命令无法传送给设备控制器。因此就需要将这些抽象要求转换为具体要求。这一转换工作只能由驱动程序来完成，因为在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、参数和数据应分别送往哪个寄存器。如:将逻辑盘块号转换为具体的盘面、磁道和扇区 检查I/O请求的合法性 如:打印机请求读, 以读方式打开磁盘后请求写 读出和检查设备的状态 如:读出并检查状态是否为就绪, 确定启动控制器或等待 传送必要的参数 对于许多设备，特别是块设备，除必须向其控制器发送启动命令外，还需传送必要的参数。例如在启动磁盘进行读/写之前，应先将本次要传送的字节数和数据应到达的主存始址，送入控制器的相应寄存器中。 工作方式的设置 如:异步通信, 先设置波特率、校验方式、停止位等 启动I/O设备 驱动程序发出I/O命令后，基本的I/O操作是在设备控制器的控制下进行的。通常，I/O操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时驱动（程序）进程把自己阻塞起来，直到中断到来时才将它唤醒。 当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下: I/O控制方式设备管理的主要任务之一是控制设备和内存或处理机之间的数据传送。对I/O设备的控制，随着软硬件的发展前后出现过如下的控制方式：使用轮询的可编程I/O方式，使用中断的可编程I/O方式，直接存储器访问（DMA）方式，I/O通道控制方式. 前两种是以字节为单位进行数据传递，后两种是以数据块为单位进行数据传递。下面对这些方式进行介绍。 程序直接控制方式该图是展示了程序I/O方式的流程。 以完成一次读操作为例程序直接控制的流程： CPU通过控制线向I/O控制器发出一个读指令，I/O控制器会根据CPU的要求启动相应的设备，并将这个设备相应的状态设置为1，表示设备忙碌（未就绪）。 接下来设备就准备CPU想要读入的数据，但是由于设备和CPU处理速度的差异，所以在设备还没有完成I/O之前，CPU会一直不断的轮询检查设备的状态，即状态寄存器的值。其实就是在不在的执行程序的循环，若状态为一直是1，说明设备还没有准备好要输入的数据，于是CPU会不断轮询。 如果设备已经准备好了输入的数据，设备会向I/O控制器传送要输入的数据，并且报告自身的状态是已就绪状态。 之后I/O控制器将要输入的数据放到数据寄存器中，并且将状态寄存器的值改为0（已就绪）。 在状态寄存器改为0时，CPU轮询检查到了数据已经准备好了，设备已就绪，即可将数据寄存器中的内容读入CPU自己的寄存器中，再把寄存器的内容放入内存（数据从设备到内存需要经过CPU）。这样就完成了一次读操作。 由于CPU速度远远快于I/O设备，因此CPU需要不断地测试I/O设备，这种控制方式又称为轮询或忙等。 可以看出，缺点是CPU利用率相当低，由于CPU速度远远快于I/O设备，致使绝大部分时间都在测试I/O设备是否已经完成数据传输，从而造成CPU的极大浪费。另外，每个字的读/写都需要CPU的帮忙。 中断控制方式 该图是展示中断驱动I/O方式的流程。 引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/0的进程阻塞，先切换到别的进程执行。 以数据输入为例，当用户进程需要输入数据时，由处理器向设备控制器发出一条I/O指令启动设备进行输入。在输入数据的同时，CPU可以做其他工作。当输入完成时，设备管理器向CPU发出一个中断信号，CPU接收到中断信号以后，转去执行设备中断处理程序。设备终中断处理程序将输入数据寄存器中的数据传送到内存的指定单元中，供要求输入的进程使用，然后再启动设备去读下一个数据。 优点：有了中断硬件的支持后，CPU与I/O设备之间可以并行工作，CPU只需要收到中断后处理即可，大大提高了CPU利用率。 缺点：如果每台设备每输入/输出一个数据，都要求中断CPU，这样在一次数据传送过程中的中断次数太多，从而耗费大量CPU时间。设备与CPU之间的数据交换仍以字（节）为单位。 直接存储器访问（DMA）方式DMA方式的进入：为了适应一次传送大量数据的应用要求，以及尽量减少CPU对高速外设的干预。与“中断驱动方式”相比，DMA（Direct Memory Access，直接存储器存取。主要用于块设备的I/O控制）有这样几个改进： 数据传送的单位是块，不再是一个字一个字的传送。 数据的流向是从设备直接放入内存，或者直接从内存到设备，不再需要CPU干预。 仅在一个块或多个块的开始和结束时，才需要CPU干预。 DMA控制器的组成DMA控制器组成：主机（CPU）—控制块的接口、I/O控制逻辑、块设备—控制器接口。 命令/状态寄存器CR：用于存放CPU发来的I/O命令，或设备的状态信息。 内存地址寄存器MAR：在设备向内存输入数据时，MAR表示输入的数据应该存放到内存的什么位置，在内存向设备输出数据时，MAR表示要输出的数据放在内存的什么位置。 数据寄存器DR:暂存从设备到内存，或者从内存到设备的数据。 数据计数器DC:表示剩余要读/写的字节数。 DMA工作过程 该图就是DMA工作过程。 以数据输入为例，当用户进程需要输入数据时，CPU将准备存放数据的内存起始地址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器和传送字节计数器中，并启动设备开始进行输入。 在输入数据的同时，CPU可以去做其他事情，输入设备不断地挪用CPU工作周期，将数据寄存器中的数据源源不断地写入内存，直到要求传送的数据全部传输完毕。 DMA控制器在传输完毕时向CPU发送一个中断信号，CPU收到中断信号后转中断处理程序，中断结束后返回被中断程序。 DMA控制方式的特点为：数据传输的基本单位是数据块，而且数据是单向传输，从设备到内存或者相反。仅在传送一个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在控制器的控制下完成。 优点：设备和CPU可以并行工作，同时设备与内存的数据交换速度更快，并且不需要CPU干预。 缺点：数据传送的方向、存放输入数据的内存起始地址及传送数据的长度等都由CPU控制，并且每台设备都需要一个DMA控制器，当设备增加时，多个DMA控制器的使用也不经济。 I/O通道控制方式为了进一步减少CPU对I/O操作的干预，引入了通道。 通道控制方式与DMA类似，也是一种以内存为中心，实现设备与内存直接数据交换的控制方式。与DMA相比，通道需要的CPU干预更少，即把对一个数据块的读写为单位的干预减少为对一组数据块读写为单位的干预，而且可以做到一个通道控制多台设备。 通道本质上是一个简单的处理器，它独立于CPU，有运算和逻辑，有自己的指令系统，也在程序控制下工作，专门负责输入、输出控制，具有执行I/O指令的能力，并通过执行通道I/O程序来控制I/O操作。通道的指令系统比较简单，一般只有数据传送指令、设备控制指令等。 在通道控制方式中，CPU只需要发出启动指令，指出要求通道执行的操作和使用的I/O设备，该指令就可以启动通道并使该通道从内存中调出相应的通道程序执行。 通道控制工作方式 以数据输入为例，当用户进程需要输入数据时，CPU发出启动指令指明要执行的I/O操作、所使用的设备和通道。 当对应通道接收到CPU发来的启动指令后，把存放在内存中的通道程序读出，并执行通道程序，控制设备将数据传送到内存中指定的区域。在设备进行输入的同时，CPU可以去做其他事情。 当数据传送结束后时，设备控制器向CPU发送一个中断请求，CPU收到中断信号后转中断处理程序，中断结束后返回被中断程序。 优点：解决了I/O操作的独立性和各部件工作的并行性。不仅能实现CPU与通道的并行操作，而且通道与通道之间也能实现并行操作，各个通道上的外设也能实现并行操作，从而提高了整个系统效率。 缺点：需要更多硬件（通道处理器），成本较高，常用于大型数据交互的场合。 小结]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针2]]></title>
    <url>%2Funcategorized%2F%E6%8C%87%E9%92%882%2F</url>
    <content type="text"><![CDATA[指针除了可以和一维数组、二维数组进行结合，也可以作为函数的返回值或者指向一个函数。下面就从这两个方面入手，看看指针与函数的有趣结合。 指针作为函数返回值函数作为C语言的基本组成模块，包括函数首部和函数体两部分。函数首部由函数返回值类型、名字、参数类型、参数等组成；函数体又可以分为说明语句与执行语句。 12345返回值类型 函数名(形参类型 形参)//函数首部&#123; //函数体 说明语句 执行语句&#125; 其中返回值类型除了几种基本数据类型以外，还可以返回一个指针值，则该函数就称为指针类型的函数。例如： int *fun(int x) 该函数名为fun，fun两侧的运算符分别为“”和“()”，由于“()”的优先级高于“”，故fun()首先代表一个函数，然后与前面的“*”结合，表示返回值是一个指针，而int则表示该指针指向的数据类型为整型，即返回值为指向整型变量的指针类型。常见的返回指针值的函数有字符串复制函数。 123456789101112char *strcpy(char *s1,char *s2)&#123; char *p=s1; while(*s1++=*s2++); return p;&#125;void main()&#123; char s[20]=&quot;welcome&quot;; printf(&quot;%s\n&quot;,strcpy(s,&quot;you&quot;));&#125; 运行结果为： you 指针指向一个函数在说明这个问题之前，先对函数在内存中的存储做个简单的介绍。指针之所以可以指向函数，是因为函数被分配在代码区一段连续的内存里面，函数名称存储的为该内存块的入口地址，故可以使用指针来调用函数。当函数被调用时，函数的形参从右至左依次压入栈中，且连续。因此对于不确定参数个数的函数，只要取得了第一个形参的地址，就可以依次取得后面参数的值。这也是printf函数能够格式化打印任意个数变量值的原因，其参数从右至左依次压栈，输出时从左至右依次弹出。下面以求n个数的最大值为例: 123456789101112int max(int n,int ...)&#123; int maxnum = *(&amp;n+1); for(int i=2;i&lt;=n;i++) &#123; if(maxnum&lt;(*(&amp;n+i))) maxnum = *(&amp;n+i); &#125; return maxnum;&#125; 其中n为要输入参数的个数，(&amp;n+1)就得到了第一个待比较数字的值，(&amp;n+i)就得到了第i个待比较数字的值，i一直取到n。 下面继续，指向函数的指针变量的定义如下： int (*p)(); 首先(*p)说明p是一个指针变量，后面的()则代表了该指针指向为某一个函数，而int代表了该函数的返回值后为整型。使用函数对该指针变量进行赋值操作： p = funname; 则可以使用(*p)代替函数名funname进行函数调用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2Funcategorized%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针重要吗指针在C语言中占据着重要的地位，指针有效的取代了在低端语言（如汇编语言与机器代码）直接使用内存地址。指针又比较贴近硬件，编译器能够很容易的将指针翻译为机器代码，这使指针操作时的计算机负担较少，同时简化一些C语言编程任务，能够提高程序的运作速度。 正是由于比较贴近硬件，并且指针可以与C语言中的其他数据结构（如数组、链表、结构体、函数）进行结合，可以说是贯穿了整本C语言。使得对于初学计算机编程的人理解起来有些难度。本文将结合图像和示例对指针的知识进行整理汇总，记录指针的学习过程，让指针也变得简单起来。 指针的定义指针（英语：Pointer）在百科中给出的定义是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。 从这个定义中可以得到以下信息，首先指针也是一种数据类型，就像我们前面学到的int,char,float,double等基础数据类型。同样的指针也可以像其他基础数据类型一样定义变量，不同的地方在于指针变量中保存的是一个存储器的地址。（补充：程序中所有的数据都是存储在内存中的，内存被分成一个个的内存单元，每个内存单元又有一个地址。系统内存就像是带有门牌号的小房间，如果要使用某个房间，就需要得到房间的门牌号。而指针变量存储的就是门牌号，即也就是存储器地址）。指针定义变量的方式如下： 123456int *a,b=5;char *c,d=&apos;m&apos;;float *f,g=6.0;a = &amp;b;c = &amp;d;f = &amp;g; int *为整型指针数据类型，定义了一个存储整型变量存储地址的指针变量a char *为字符型指针数据类型，定义了一个存储字符型变量存储地址的变量c float *为单精度浮点型指针数据类型，定义了一个存储浮点型变量存储地址的变量f 指针变量的赋值两个指针运算符： 地址运算符&amp;取内存中变量的地址，例如&amp;b,值为整型变量b的内存地址。 取值运算符* 获取指针变量所指向变量的值，例如a,值为5。（注意与int *中的\相区别） a = &b;代表取出整型变量b的地址赋值给a，图中简单表示为2000赋值给a,即a指向变量b,a中存储了变量b的内存地址2000。指针变量c和f的赋值也一样如图所示。 这里要区分两个容易混淆的概念： 指针的类型指针的类型是指针变量本身的类型，指针变量在内存中占据4个字节，存储32位的内存地址码。 指针变量a的类型为int * 指针变量c的类型为char * 指针变量f的类型为float * 指针指向的类型指向的类型是当前指针存储的内存地址中所存储变量的类型。 a指向的类型为int c指向的类型为char f指向的类型为float 指针与一维数组我们都知道数组名是代表数组首元素地址的符号常量，而指针变量又可以存储地址，所以数组不仅可以通过数组名+下标的方式访问，也可以通过指向它的指针变量来访问。 指向数组的指针变量我们前面定义的指针变量都是指向一个基础数据类型的变量，指向数组的指针变量定义方式也类似。 12int c[5];int *p = c; 表达式(p+1)或(c+1)都代表数组元素c[1]，其中p+1和c+1都代表c[1]的地址&amp;c[1]。 数组名称c为常量，故任何对数组名称赋值的操作都是错误的。 C语言不会对地址操作做越界检查，故数组越界不会报错，这也是程序容易出错的地方。 12int (*p)[5];int *p[5]; 上面第一个定义方式为，首先计算()，*p代表p是一个指针变量，然后是[5],代表p指向一个大小为5的数组，最后int，代表p指向的是一个存储整型变量的数组。即定义数组指针p，指向一个存储5个整型元素的数组。 [5]的优先级要高于*，故p首先是一个大小为5的数组，其存储的数据类型为指针变量，而指针指向的数据类型为整型int。 指针与二维数组定义二维整型数组如下 1int a[3][3] = &#123;&#123;14,16,19&#125;,&#123;22,55,88&#125;,&#123;33,54,32&#125;&#125;; 二维数组a的元素是按行进行存储的，可以将a数组的3行看成3个分数组：a[0],a[1],a[2]。每个分数组是含3个列元素的一维数组。如下图所示： 数组名a是指向0号分数组的指针常量，值为2000，同样不能够给a赋值。a+0，a+1，a+2则分别表示0号分数组，1号分数组，2号分数组，对应存储器地址值为2000，2004，2008。其中a[0],a[1],a[2]为三个一维分数组的数组名称，这三个数组名存储的地址又分别指向a[0][0],a[1][0],a[2][0]，对应的数值为3000，3006，3012。a[0]+1和a[0]+2则是分别指向a[0][1],a[0][2]的指针常量,对应的地址值为3002，3004。 虽然a与a[0]的地址都是2000，但是并不等价，a的基类型字节数为4，a[0]为2，也可以从a+1与a[0]+1的不同结果看出。以下是二维数组不同表示形式的含义与内容：]]></content>
  </entry>
  <entry>
    <title><![CDATA[ARP网关欺骗]]></title>
    <url>%2Funcategorized%2FARP%E7%BD%91%E5%85%B3%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[大家好，唐三藏奉旨投西，我是随行记者小唐。就在前几日，孙行者因故打死几个剪径的强盗，唐长老盛怒之下将其赶走。正好让六耳猕猴钻了空子，打昏了三藏，夺走了行李。沙悟净前去索要，竟被六耳猕猴告之他要自行前去取经。悟净不以为然，言道：“老哥啊，没有唐僧去，哪个佛祖都不会传经给你，你这才是白忙活哩。”六耳道：“贤弟啊，你一直就挺懞懂，不太了解情况。其实啊，我这已经人员齐备，整装待发了，你来看。”说着便请出来一匹白马，一个唐三藏，跟着一个八戒，一个沙僧。从后来事态发展的情况来看，六耳的取经队伍恐怕是瞒不过佛祖，自然也无法取来真经。但是如果将真经类比为数据包，六耳猕猴类比为ARP攻击程序，在计算机网络的世界中，这却是特别容易成功的。那这究竟是怎么一回事呢？ARP又是什么呢？ 以太网络别忙，解释这些问题之前，我们先来简单回顾一下计算机之间时如何进行联系的。首先整个计算机网络是由一个又一个的子网所构成，子网可以简单理解为所有连接同一个路由器的计算机所构成。在同一个子网内的计算机，相互之间是可以直接进行通信的，使用的是以太协议，又叫以太网。但是如果想同另一个子网的计算机进行通信就必须经过路由器，此时的路由器又可以叫做网关。在局域网中通信时使用的是MAC地址，而不是常见的IP地址。所以在局域网的两台主机间通信时，必须要知道对方的MAC地址，这就是ARP协议要做的事，将IP地址转换为MAC地址。 通过 ARP 查询目标路由器的 MAC 地址ARP 就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”然后就会有设备回答：“这个 IP 地址是我的，我的 MAC 地址是××××。”如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。 ARP缓存如果每次发送包都要这样查询一次，网络中就会增加很多 ARP包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用。也就是说，在发送包时，先查询一下 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址，而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询。 ARP欺骗ARP攻击程序就是一直在应答：“这个 IP 地址（其实是网关的IP地址）是我的，我的 MAC 地址是××××。”这是时候其他设备就会将该设备当作网关，所有的与其他子网交互的数据都会发到该设备，从而实现了ARP欺骗，就会出现无法上网或者数据泄露的风险。使用kali Linux 的arpspoof工具可以轻松实现这一功能。命令参数如下： arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host(-i指定网卡接口，-t指定目标机器，-r当前网关)]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言版本之谜]]></title>
    <url>%2FC%2FC%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E4%B9%8B%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[赋闲在家，可能反而给了我们更多的时间来进行思考。偶然看到一段蛮有吸引力的视频，视频在文章的末尾，只有十分钟，即使是鸡汤，感觉也是一碗可以榨取出营养的鸡汤。 为什么大多数人不能成功作者提出，为什么大多数人都不会真正的成功？我们周围的环境都在试图将我们拉向平庸，并且引力非常大，而且我们中的大多数人都无法摆脱这些诱惑。 这些诱惑可以使你的大脑感到愉悦，甚至有的诱惑还能欺骗我们自己的大脑，让我们自己感觉到自己在学习东西，从而减少一些无所事事的负罪感。我们以电子媒介中的新闻为例，这个电子媒介勾画的世界不存在秩序和意义，我们不必把它当回事。再残忍的谋杀，再具破坏力的地震，再严重的政治错误，只要新闻播音员说一声“好，现在我们看下一篇报道”，一切就可以马上从我们的脑海中消失。新闻播音员意思是我们为上一条新闻花费的时间已经够多了，不必一直念念不忘，应该将注意力转移到下一篇新闻了。在这里我们看到的不仅是零散不全的新闻，而且没有背景，没有结果，更加没有价值，新闻成了纯粹的娱乐。 信息过剩我们每天刷着手机，接受海量的信息，几天下来，可能比古人一辈子获得的信息都要多了。但是能够对我们有价值，能够促成我们行动的信息却少之又少。我们可能一辈子都无法参与到中东的军事行动，英国脱欧的政治博弈，顶多在与朋友闲聊的时候多说两句话。新闻尚如此，可见我们每天对着手机和电脑会遇到多少诱惑。当我们获得了有价值的信息，打算有所行动的时候，会开始惧怕失败。 惧怕失败作者讲的第一个原因就是人们会本能的惧怕失败，在他们眼里如果他们把一件事情搞砸了，那就意味着他们本身就很糟糕，任何失败都会证明他们不够好。但是你可以从失败中获得气馁，也可以从中获得经验。避免了失败也就失去了许多获得经验的机会。这里很多人会说，人们惧怕失败是因为有的人根本承担不起失败的后果。没错，但是生活中不一定都是一些大事情，还有一些小事情，比如作者说的写博客的例子。 花时间去比较作者还提到不要过多的关注别人，嫉妒别人。如果你关注别人过多，就会容易失去自我，你的价值和行动会很难保持一致，这会让你感到空虚和不快乐。作者还说了一句很有道理的话，“嫉妒和怨恨就像自己喝下毒药，却期待别人死去一样”。我们中的大多数人都会选择娱乐和消遣，而不是学习和成长，因为后者很难。遇到困难应该感到高兴，因为这意味着大多数人都不会选择做这件事，竞争并不激烈。 希望作者的视频能够促成你的某些行动。不然就是一碗没有意义的鸡汤了。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CRC校验算法JAVA版]]></title>
    <url>%2FIot%2Fcrc-java%2F</url>
    <content type="text"><![CDATA[CRC校验又称为循环冗余校验，是数据通讯中常用的一种校验算法。它可以有效的判别出数据在传输过程中是否发生了错误，从而保障了传输的数据可靠性。 CRC16 Modbus校验算法JAVA版 1234567891011121314151617181920212223242526272829303132333435//大端对齐 static byte[] crc16_tab_h = &#123; (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40 &#125;; //小端对齐 static byte[] crc16_tab_l = &#123; (byte) 0x00, (byte) 0xC0, (byte) 0xC1, (byte) 0x01, (byte) 0xC3, (byte) 0x03, (byte) 0x02, (byte) 0xC2, (byte) 0xC6, (byte) 0x06, (byte) 0x07, (byte) 0xC7, (byte) 0x05, (byte) 0xC5, (byte) 0xC4, (byte) 0x04, (byte) 0xCC, (byte) 0x0C, (byte) 0x0D, (byte) 0xCD, (byte) 0x0F, (byte) 0xCF, (byte) 0xCE, (byte) 0x0E, (byte) 0x0A, (byte) 0xCA, (byte) 0xCB, (byte) 0x0B, (byte) 0xC9, (byte) 0x09, (byte) 0x08, (byte) 0xC8, (byte) 0xD8, (byte) 0x18, (byte) 0x19, (byte) 0xD9, (byte) 0x1B, (byte) 0xDB, (byte) 0xDA, (byte) 0x1A, (byte) 0x1E, (byte) 0xDE, (byte) 0xDF, (byte) 0x1F, (byte) 0xDD, (byte) 0x1D, (byte) 0x1C, (byte) 0xDC, (byte) 0x14, (byte) 0xD4, (byte) 0xD5, (byte) 0x15, (byte) 0xD7, (byte) 0x17, (byte) 0x16, (byte) 0xD6, (byte) 0xD2, (byte) 0x12, (byte) 0x13, (byte) 0xD3, (byte) 0x11, (byte) 0xD1, (byte) 0xD0, (byte) 0x10, (byte) 0xF0, (byte) 0x30, (byte) 0x31, (byte) 0xF1, (byte) 0x33, (byte) 0xF3, (byte) 0xF2, (byte) 0x32, (byte) 0x36, (byte) 0xF6, (byte) 0xF7, (byte) 0x37, (byte) 0xF5, (byte) 0x35, (byte) 0x34, (byte) 0xF4, (byte) 0x3C, (byte) 0xFC, (byte) 0xFD, (byte) 0x3D, (byte) 0xFF, (byte) 0x3F, (byte) 0x3E, (byte) 0xFE, (byte) 0xFA, (byte) 0x3A, (byte) 0x3B, (byte) 0xFB, (byte) 0x39, (byte) 0xF9, (byte) 0xF8, (byte) 0x38, (byte) 0x28, (byte) 0xE8, (byte) 0xE9, (byte) 0x29, (byte) 0xEB, (byte) 0x2B, (byte) 0x2A, (byte) 0xEA, (byte) 0xEE, (byte) 0x2E, (byte) 0x2F, (byte) 0xEF, (byte) 0x2D, (byte) 0xED, (byte) 0xEC, (byte) 0x2C, (byte) 0xE4, (byte) 0x24, (byte) 0x25, (byte) 0xE5, (byte) 0x27, (byte) 0xE7, (byte) 0xE6, (byte) 0x26, (byte) 0x22, (byte) 0xE2, (byte) 0xE3, (byte) 0x23, (byte) 0xE1, (byte) 0x21, (byte) 0x20, (byte) 0xE0, (byte) 0xA0, (byte) 0x60, (byte) 0x61, (byte) 0xA1, (byte) 0x63, (byte) 0xA3, (byte) 0xA2, (byte) 0x62, (byte) 0x66, (byte) 0xA6, (byte) 0xA7, (byte) 0x67, (byte) 0xA5, (byte) 0x65, (byte) 0x64, (byte) 0xA4, (byte) 0x6C, (byte) 0xAC, (byte) 0xAD, (byte) 0x6D, (byte) 0xAF, (byte) 0x6F, (byte) 0x6E, (byte) 0xAE, (byte) 0xAA, (byte) 0x6A, (byte) 0x6B, (byte) 0xAB, (byte) 0x69, (byte) 0xA9, (byte) 0xA8, (byte) 0x68, (byte) 0x78, (byte) 0xB8, (byte) 0xB9, (byte) 0x79, (byte) 0xBB, (byte) 0x7B, (byte) 0x7A, (byte) 0xBA, (byte) 0xBE, (byte) 0x7E, (byte) 0x7F, (byte) 0xBF, (byte) 0x7D, (byte) 0xBD, (byte) 0xBC, (byte) 0x7C, (byte) 0xB4, (byte) 0x74, (byte) 0x75, (byte) 0xB5, (byte) 0x77, (byte) 0xB7, (byte) 0xB6, (byte) 0x76, (byte) 0x72, (byte) 0xB2, (byte) 0xB3, (byte) 0x73, (byte) 0xB1, (byte) 0x71, (byte) 0x70, (byte) 0xB0, (byte) 0x50, (byte) 0x90, (byte) 0x91, (byte) 0x51, (byte) 0x93, (byte) 0x53, (byte) 0x52, (byte) 0x92, (byte) 0x96, (byte) 0x56, (byte) 0x57, (byte) 0x97, (byte) 0x55, (byte) 0x95, (byte) 0x94, (byte) 0x54, (byte) 0x9C, (byte) 0x5C, (byte) 0x5D, (byte) 0x9D, (byte) 0x5F, (byte) 0x9F, (byte) 0x9E, (byte) 0x5E, (byte) 0x5A, (byte) 0x9A, (byte) 0x9B, (byte) 0x5B, (byte) 0x99, (byte) 0x59, (byte) 0x58, (byte) 0x98, (byte) 0x88, (byte) 0x48, (byte) 0x49, (byte) 0x89, (byte) 0x4B, (byte) 0x8B, (byte) 0x8A, (byte) 0x4A, (byte) 0x4E, (byte) 0x8E, (byte) 0x8F, (byte) 0x4F, (byte) 0x8D, (byte) 0x4D, (byte) 0x4C, (byte) 0x8C, (byte) 0x44, (byte) 0x84, (byte) 0x85, (byte) 0x45, (byte) 0x87, (byte) 0x47, (byte) 0x46, (byte) 0x86, (byte) 0x82, (byte) 0x42, (byte) 0x43, (byte) 0x83, (byte) 0x41, (byte) 0x81, (byte) 0x80, (byte) 0x40 &#125;; public byte[] calcCrc16(byte[] data, int offset, int len) &#123; return calcCrc16(data, offset, len, 0xffff); &#125; public byte[] calcCrc16(byte[] data, int offset, int len, int preval) &#123; int ucCRCHi = (preval &amp; 0xff00) &gt;&gt; 8; int ucCRCLo = preval &amp; 0x00ff; int iIndex; for (int i = 0; i &lt; len; ++i) &#123; iIndex = (ucCRCLo ^ data[offset + i]) &amp; 0x00ff; ucCRCLo = ucCRCHi ^ crc16_tab_h[iIndex]; ucCRCHi = crc16_tab_l[iIndex]; &#125; int value = ((ucCRCHi &amp; 0x00ff) &lt;&lt; 8) | (ucCRCLo &amp; 0x00ff) &amp; 0xffff; return int2Bytes(value,2); &#125; public byte[] int2Bytes(int value, int length) &#123; byte[] b = new byte[length]; for (int k = 0; k &lt; length; k++) &#123; b[length - k - 1] = (byte) ((value &gt;&gt; 8 * k) &amp; 0xff); &#125; return b; &#125; CRC16查表算法代码采用的多项式为CRC-16/IBM： X16+X15+X2+1C语言版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static uint16_t const CRC16Table[256] = &#123; 0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040&#125;;uint16_t CRC16(uint8_t* dataIn, int length)&#123; uint16_t result = 0; uint16_t tableNo = 0; for(int i = 0; i &lt; length; i++) &#123; tableNo = ((result &amp; 0xff) ^ (dataIn[i] &amp; 0xff)); result = ((result &gt;&gt; 8) &amp; 0xff) ^ CRC16Table[tableNo]; &#125; return result; &#125; JAVA版： 123456789101112131415161718192021222324252627282930313233//小端对齐 private static final int[] CRC16Table = &#123; 0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040 &#125;;public byte[] CRC16(byte[] bytes) &#123; int result = 0xFFFF; int tableNo = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; tableNo = ((result &amp; 0xff) ^ (bytes[i] &amp; 0xff)); result = ((result &gt;&gt; 8) &amp; 0xff) ^ CRC16Table[tableNo]; &#125; return int2Bytes(result, 2); &#125;]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>CRC校验算法</tag>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网体系结构]]></title>
    <url>%2FIot%2Fiot-architecture%2F</url>
    <content type="text"><![CDATA[目前国内物联网通信领域，主要分为两大阵营：以三大运营商和华为为主的NB通信方式，以阿里巴巴和Lora联盟为主的Lora和LoraWan通信方式（还有传统的GPRS通信方式和SMS通信方式）。 NB借用运营商已有的基站作为网络节点发送数据，而Lora多用于自组网，需要自行搭建网关。两种方式各有优缺点。例如有些共享单车就采用了短信（SMS）+NB+蓝牙的通信方式。其中NB通信方式多采用Coap协议进行。Coap协议是基于UDP的应用层协议，较Http轻量，专为物联网终端设计，采用无状态连接。因为采用无状态连接故Coap并不擅长主动下发命令。Mqtt协议基于TCP协议，有商业和开源的mqtt broker供选择，支持ACL访问控制、集群、共享订阅等高级功能，能够实现实时命令下发，相较于TCP协议大大简化服务器端的开发工作量。采用NB通信方式需要从电信运营商处采购物联卡，并且开通NB流量套餐。目前三大运营商皆有物联卡。 为了方便管理设备的连接，通信协议的解析，以及设备的鉴权，各大运营商都推出了自己的Iot平台。比如中国移动的OneNet平台，华为的OceanConnect平台，以及中国电信在OceanConnect平台基础上，开发出的中国电信Iot平台。目前OceanConnect平台为收费使用且价格不菲，中国电信则免费使用，但是限制只能够使用中国电信的物联卡，且中国电信的物联卡也只能将数据发送到中国电信Iot平台，实现了双向绑定。中国移动的物联卡目前没有这一限制，并且可以使用GPRS（2G\3G\4G\4G+）通信方式。 Iot平台都自带设备接入功能，设备状态管理功能，提供了通信协议解析的接口。用户可根据终端设备的通信协议，安装平台接口标准自行编写编解码插件用于数据的解析，即将Hex格式的数据解析为json格式，反之亦然。Iot平台与用户应用平台的交互也都提供了api接口，用户在应用平台调用对应的接口即可。关于解析好的数据，可以通过订阅/推送的方式发送到应用平台，也可以应用平台通过接口主动请求获取数据。]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>物联网通信</tag>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络是个邮局]]></title>
    <url>%2FComputer-Networking%2FHistory-of-Computer-Networking%2F</url>
    <content type="text"><![CDATA[网络网络（network）是一组具有通信能力的设备相互连接而形成的。在这个定义中，设备可以是主机（host）,也可以是连接设备，如连接网络到其他网段的路由器（routers）、将设备连接到一起的交换机、对电信号进行数模转换的调制解调器等。 局域网局域网（LAN）通常是私有的，连接一个办公室、大楼或校园内的一些主机。 广域网广域网（WAN）也是由具有通信能力的设备相互连接而形成的。局域网通常覆盖范围受限，广域网则具有更广的地理覆盖范围。 网络是个邮局试想一下，假如你开发了一套应用软件，这些运行在不同终端系统上（计算机、手机、平板）的程序，相互之间需要传输数据。那么运行在一台终端上的程序是如何使用网络设备（网卡、交换机、路由器）将数据传输给另外一台终端上的程序呢？ 实际上计算机（其他终端相同）提供了一套支持多种通信协议的网络通信接口（socket interface），该通信接口明确了，运行在计算机上的程序如何让网络设备将数据发送到另外一台设备。即该网络通信接口制定了一种规则，应用程序必须遵守该规则，才能顺利将数据发送到目标程序。举个例子：艾家庄的艾丽丝小姐想要通过邮局给鲍家庄的鲍博先生写一封信。当然艾丽丝把信写好以后，不能就随手把信往窗外一扔，然后万事大吉，这样鲍博永远也收不到信件。正确的做法是，邮局需要艾丽丝将信装在一个信封里面，信封上写上鲍博的名字、家庭地址、邮政编码，贴上一个邮票。最后把信封投进附近的邮箱里面，这样就能发信件发出去了。因此，邮局提供了一套邮寄信件的“通信接口”，或者说制定了一套规则。艾丽丝必须遵守邮局制定的邮寄信件规则，才能成功将信邮给鲍博。同样，网络也有自己的通信规则（socket interface），应用程序想通过网络发送数据也必须遵守这种规则。当然邮局不止提供一种邮寄信件的服务，同样网络也支持各种协议。 什么是协议协议定义了两个或多个通信实体之间交换的消息的格式和顺序，以及在消息或其他事件的传输或接收上采取的动作。 文章参考自Computer networking: a top-down approach seventh edition。]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>计算机网络 Internet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题开启文章分享功能及去除图片上的分享按钮]]></title>
    <url>%2FHexo%2F2019062712%2F</url>
    <content type="text"><![CDATA[Hexo的Next主题中已经集成了文章分享功能，我们只需要clone下github上的分享插件，并修改Next主题配置文件就可以实现文章的分享功能。具体操作如下。 配置Next主题配置文件打开主题配置文件检索baidushare配置如下： 12345678910111213141516171819baidushare: type: slideneedmoreshare2: enable: true postbottom: enable: true options: iconStyle: true boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 下载文章分享所需插件配置文件中已经给出了文章分享所需插件的github仓库地址，即 https://github.com/theme-next/theme-next-needmoreshare2仓库中也给出了使用方法，即首先通过命令行进入themes/next主题目录下，然后将插件clone下来： 12$ cd themes/next$ git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 后期需要更新的话就是通过以下命令： 12$ cd themes/next/source/lib/needsharebutton$ git pull 至此，我们就可以在文章的尾部看到分享文章的按钮了。但是当我把鼠标放在文章中的图片上时，发现图片的右上角也加上了一排分享的按钮，经过分析，找到了添加分享的代码，将其注释一下就大功告成了，实现清清爽爽的页面。找到路径为themes\next\layout_partials\share\baidushare.swig的文件，将代码中的image注释掉。大约在26-30行，代表设置分享按钮在文章底部时的效果；42-46行，代表设置文章分享按钮在侧边时的效果。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;script&gt; window._bd_share_config = &#123; "common": &#123; "bdText": "", "bdMini": "2", "bdMiniList": false, "bdPic": "" &#125;, "share": &#123; "bdSize": "16", "bdStyle": "0" &#125;, // "image": &#123; // "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"], // "viewText": "分享到：", // "viewSize": "16" // &#125; &#125; &lt;/script&gt;&#123;% elif theme.baidushare.type === "slide" %&#125; &lt;script&gt; window._bd_share_config = &#123; "common": &#123; "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "" &#125;, // "image": &#123; // "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"], // "viewText": "分享到：", // "viewSize": "16" // &#125;, "slide": &#123; "bdImg": "5", "bdPos": "left", "bdTop": "100" &#125; &#125; &lt;/script&gt; 注释掉以后执行Hexo g重新生成页面（记得cd .. 退回到Hexo博客的根目录欧），就可以看到图片上已经没有分享按钮了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Git关联Github]]></title>
    <url>%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F2019062616%2F</url>
    <content type="text"><![CDATA[本地git关联github1.输入你的github注册邮箱,生成本地ssh key $ ssh-keygen -t rsa -C “your_email@youremail.com“ 2.然后成功后会在User文件夹对应的用户下创建.ssh文件夹，其中有一个id_rsa.pub文件，我们复制其中的key,进入 Account Settings（账户配置），左边选择SSH and GPG Keys选项。其中的title随便填，下面的粘贴在你电脑上生成的key。 3.验证是否绑定本地成功，在git-bash中验证，输入指令： $ ssh -T git@github.com 如果第一次执行该指令，则会提示是否continue继续，如果我们输入yes就会看到成功信息： 4.由于GitHub每次执行commit操作时，都会记录username和email，下面进行设置： $ git config –global user.name “name”//你的GitHub登陆名$ git config –global user.email “123@163.com“//你的GitHub注册邮箱 5.在github上新建一个仓库，并添加一个README.md文件，并pull到本地： $ git pull “仓库的ssh链接” 6.常用git命令 git init //把这个目录变成Git仓库git add README.md //文件添加到仓库git add . //不但可以跟单一文件，还可以跟通配符，添加当前目录下所有文件git commit -m “first commit” //把文件提交到本地仓库git remote add origin git@github.com:yourname/youremail.git //关联远程仓库git pull XXX master –allow-unrelated-histories //允许合并不相关历史的内容git push -u origin master //上传到远程仓库]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换个角度看编解码插件开发]]></title>
    <url>%2FIot%2Foceanconnect-plugin-dev%2F</url>
    <content type="text"><![CDATA[编解码概述书写编解码插件之前首先需要书写Profile文件，定义如下。 Profile文件用于描述一款设备的能力特性。IOT平台通过解析Profile文件，获取该设备支持的服务（通信协议里面的一条完整报文）、属性（报文中的一个字段）、命令（报文中的一个字段）等信息。 IOT平台通过编解码插件，对NB设备上报的数据和下发给NB设备的命令进行格式转换，即将设备上报的16进制格式的报文转换成json，json数据的具体属性名称将由Profile文件来确定。 知识储备熟悉javase基础编程，maven项目管理工具基本命令，jackson类库。 开发工具Eclipse，jdk1.8，maven，NB设备通信协议。 编解码结构分析Profile结构Profile文件是一个深度为四级的文件夹如图所示。 红色方框中为第一级目录，目录名称为当前项目的名称，命名规则为：设备类型-厂商ID-设备型号，例如WellMonitor_Apple_A1865，对应图中功能结构中的Product模块。 绿色方框中为第二级目录，包含两个文件夹profile和service。profile文件夹下放置一个devicetype-capability.json，被用来描述一款设备的能力特征，包括设备类型、厂商、型号、协议类型以及提供的服务类型。相当于对当前整个Profile项目信息的一个概述。service文件夹下则包含设备具备的服务能力，每个服务具备的属性、命令以及命令的参数，对应图中Service模块。 蓝色方框中代表三级目录，代表具体的服务，每个服务中又包含了属性和命令，属性用于描述设备上报数据，命令用于下发指令给设备，分别对应图中的Property模块和Command模块。 此外只有红色与蓝色方框中文件的命名可以改动，其他名称固定不变。 例如图2‑1，service中包含了WellWaterCommand代表井盖+水位设备所有的下行命令；WellWaterDeviceInfo代表该设备上报的设备信息；WellWaterTiming代表该设备定时上报的信息，共计三个服务。关于如何根据设备的通信协议划分服务，将在第三章中详细介绍。 编解码插件结构编解码插件使用java开发且jdk版本必须为1.8，maven进行项目管理，建议使用eclipse开发工具。其工程目录结构如图所示。工程的命名建议和Profile项目相同，即采用：设备类型-厂商ID-设备型号的格式。其余包名类名无需更改，即使用华为提供的名称。 其中下行数据编码表示该类将平台下发的json格式的命令转化为字节数组。 上行数据解码则表示该类将设备上报的字节数组转化为json格式数据。 主类则负责调用下行数据编码或者上行数据解码。 工具类中包含了不同数据类型之间转换的方法。 编解码插件开发Profile开发新建工程新建名称为：设备类型-厂商ID-设备型号的文件夹，例如WellMonitor_Apple_A1865，打开该文件夹新建profile和service两个子文件夹，如图所示。注意profile和service这两个文件夹名称是固定不变的。 创建概述文件打开profile文件夹新建devicetype-capability.json文件，编辑该json文件如图所示。其中每个字段所代表的含义如图所示。serviceTypeCapabilitiesJson数组包含了该Profile文件所有的服务模块，即每增加一个service都需要在这个数组中添加一个对应的json对象。例如Apple公司采用CoAP协议，设备型号为A1865的井盖设备包含三个服务（功能）模块，井盖命令、井盖开机信息，井盖定时上报信息。 Service划分关于一个设备service的划分，可以采用根据设备通信协议中上报报文的功能码进行划分的方法，即协议中一条上报报文对应一个service（通常一条报文占用一个功能码）。 Service划分步骤： 将通信协议中的报文区分为上行数据和下行数据两类。 将下行数据（命令）写在一个service里面。 将上行数据根据功能码的不同，分成若干个不同的service。 创建service打开第二级目录的service文件夹，根据步骤二devicetype-capability.json文件中serviceTypeCapabilities数组中定义的service创建对应的文件夹，文件夹名称为serviceId对应的值。每个文件夹下分别创建profile文件夹，profile文件夹下创建servicetype-capability.json文件，用来描述具体服务的功能，如图所示。 接下来编写每个service对应的servicetype-capability.json，如图所示的Profile，将井盖水位设备的所有命令下发模块单独写在了一个service中，即WellWaterCommand模块；将设备的上报数据信息按照通信协议中每个报文的功能码区分为不同的service，即WellWaterDeviceInfo（开机信息）模块与WellWaterTiming（定时上报）模块。 编写下行service下行命令在service中的书写格式如图3‑5所示。Commands数组里面存放若干个命令对象，每个命令对象包含CommandName命令的名称和paras命令携带的参数数组，以及responses命令回应数组。paras数组里面包含若干个参数对象。参数对象包含paraName等一系列属性。这每一个参数对象都对应通信协议报文中的一个属性。serviceType的值一定要与当前服务文件夹名称保持一致。 编写上行service上行属性service比命令service要简单，properties数组中存放的是设备上报上来的数据，每一个json对象对应通信协议报文中的一个属性。propertyName的值可以随意定义，dataType的值如不能根据通信协议中的默认参数值明显的判断该属性的数据类型，应找相关人员确认，否则解析将会出现数据错误。 打包Profile将WellMonitor_Apple_A1865文件夹下的profile和service文件打包为zip格式，命名为WellMonitor_Apple_A1865，并且压缩包内不能包含WellMonitor_Apple_A1865文件夹这一层目录。 编解码开发使用eclipse配置本地maven仓库，并导入华为提供的demo工程。 修改pom.xml中的&lt;artifactId&gt;XXX&lt;/artifactId&gt;和&lt;Bundle-SymbolicName&gt;XXX&lt;/Bundle-SymbolicName&gt;命名规范：设备类型-厂商ID-设备型号，与Profile文件保持一致。如图所示。 修改ProtocolAdapterImpl.java中的厂商名称与设备型号，注意与Profile保持一致。如图所示。 编写下行编码数据下行编码流程如图所示，通过获取OC平台发送过来的json数据，首先根据serviceId将对应数据保存到全局变量中，然后调用toByte方法，将各种类型的数据装换为16进制的比特数组。拼装成一条完整的报文并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 编写上行解码数据上行解码流程如图所示。通过获取OC平台发送过来的16进制比特数组格式数据，首先根据比特数组中的功能码（功能码在数据哪个位置，请从通信协议中查看），将不同服务对应的不同数据，根据通信协议将byte类型的属性转换为所需类型，保存到全局变量中，然后调用toJsonNode方法，拼装成一个Json对象并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 打包编解码打包编解码，即将该maven工程打包成jar文件。检查pom.xml中的&lt;packaging&gt;bundle&lt;/packaging&gt;值是否为bundle，不能为jar。以eclipse为例，在工程上右键选择RunAs然后选择Maven build…如图所示。 在Goals中输入clean package点击Run按钮，如图所示。 等待控制台出现BUILDSUCCESS，即可在当前项目的target目录下找到打包好的jar文件，如图所示。 新建package文件夹，文件夹下包含preload文件夹以及package-info.json描述文件，将打包好的jar文件放到preload文件夹下，如图所示。 按照内容修改package-info.json描述文件，如图所示。 最后将package文件夹压缩为package.zip,并且压缩包内不能包含package文件夹这一层目录。 上传离线插件到OC开发者平台上传Profile有两种上传方式。 登录开发者门户，选择产品开发下的添加按钮。 选择从本地导入产品创建-&gt;上传Profil文件。将上文中打包好的Profile文件WellMonitor_Apple_A1865.zip进行上传。 登录管理门户，选择设备管理-&gt;产品模型-&gt;本地导入产品模型，添加完成后会自动同步到开发者门户，然后在开发者门户继续下面的上传插件操作。 上传插件上传Profile以后就会自动生成一个产品，选择第二步编解码插件开发-&gt;插件管理-&gt;上传插件。将上文中打包好的package.zip文件上传。插件上传成功，即可注册设备进行下一步的开发。附录 点击显/隐内容 Nothing to show you.]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>编解码</tag>
        <tag>OceanConnect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堪比华为还详细的编解码插件线下开发教程]]></title>
    <url>%2FIot%2F%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E4%B9%A6%E5%86%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编解码概述书写编解码插件之前首先需要书写Profile文件，定义如下。 Profile文件用于描述一款设备的能力特性。IOT平台通过解析Profile文件，获取该设备支持的服务（通信协议里面的一条完整报文）、属性（报文中的一个字段）、命令（报文中的一个字段）等信息。 IOT平台通过编解码插件，对NB设备上报的数据和下发给NB设备的命令进行格式转换，即将设备上报的16进制格式的报文转换成json，json数据的具体属性名称将由Profile文件来确定。 前期准备知识储备熟悉javase基础编程，maven项目管理工具基本命令，jackson类库。 开发工具Eclipse，jdk1.8，maven，NB设备通信协议。 编解码结构解析Profile结构Profile文件是一个深度为四级的文件夹如图3‑4所示。 红色方框中为第一级目录，目录名称为当前项目的名称，命名规则为：设备类型-厂商ID-设备型号，例如WellMonitor_Chinastar_CSiTWLM05，对应图3‑4功能结构中的Product模块。 绿色方框中为第二级目录，包含两个文件夹profile和service。profile文件夹下放置一个devicetype-capability.json，被用来描述一款设备的能力特征，包括设备类型、厂商、型号、协议类型以及提供的服务类型。相当于对当前整个Profile项目信息的一个概述。service文件夹下则包含设备具备的服务能力，每个服务具备的属性、命令以及命令的参数，对应图3‑4中Service模块。 蓝色方框中代表三级目录，代表具体的服务，每个服务中又包含了属性和命令，属性用于描述设备上报数据，命令用于下发指令给设备，分别对应图3‑4中的Property模块和Command模块。 此外只有红色与蓝色方框中文件的命名可以改动，其他名称固定不变。 例如图2‑1service中包含了WellWaterCommand代表井盖+水位设备所有的下行命令；WellWaterDeviceInfo代表该设备上报的设备信息；WellWaterTiming代表该设备定时上报的信息，共计三个服务。关于如何根据设备的通信协议划分服务，将在第三章中详细介绍。media/4e8ad1d840e65bfc32b745a7004fb776.png 图2‑1 Profile文件结构 图2‑2 Profile功能结构 编解码插件结构编解码插件使用java开发且jdk版本必须为1.8，maven进行项目管理，建议使用eclipse开发工具。其工程目录结构如图3‑4所示。工程的命名建议和Profile项目相同，即采用：设备类型-厂商ID-设备型号的格式。其余包名类名无需更改，即使用华为提供的名称。 其中下行数据编码表示该类将平台下发的json格式的命令转化为字节数组。 上行数据解码则表示该类将设备上报的字节数组转化为json格式数据。 主类则负责调用下行数据编码或者上行数据解码。 工具类中包含了不同数据类型之间转换的方法。 图2‑3 编解码插件工程结构 编解码插件开发Profile开发新建工程新建名称为：设备类型-厂商ID-设备型号的文件夹，例如WellMonitor_Chinastar_CSiTWLM05，打开该文件夹新建profile和service两个子文件夹，如图3‑4所示。注意profile和service这两个文件夹名称是固定不变的。 图3‑1 Profile文件夹 创建概述文件打开profile文件夹新建devicetype-capability.json文件，编辑该json文件如图3‑4所示。其中每个字段所代表的含义如图3‑4所示。serviceTypeCapabilitiesJson数组包含了该Profile文件所有的服务模块，即每增加一个service都需要在这个数组中添加一个对应的json对象。例如Chinstar公司采用CoAP协议，设备型号为CSiTWLM05的井盖设备包含三个服务（功能）模块，井盖命令、井盖开机信息，井盖定时上报信息。 Service划分关于一个设备service的划分，可以采用根据设备通信协议中上报报文的功能码进行划分的方法，即协议中一条上报报文对应一个service（通常一条报文占用一个功能码）。 Service划分步骤： 将通信协议中的报文区分为上行数据和下行数据两类。 将下行数据（命令）写在一个service里面。 将上行数据根据功能码的不同，分成若干个不同的service。 图3‑2 Profile概述文件 图3‑3 Profile文件字段含义 创建service打开第二级目录的service文件夹，根据步骤二devicetype-capability.json文件中serviceTypeCapabilities数组中定义的service创建对应的文件夹，文件夹名称为serviceId对应的值。每个文件夹下分别创建profile文件夹，profile文件夹下创建servicetype-capability.json文件，用来描述具体服务的功能，如图3‑4所示。 图3‑4 service文件结构 接下来编写每个service对应的servicetype-capability.json，如图3‑4所示的Profile，将井盖水位设备的所有命令下发模块单独写在了一个service中，即WellWaterCommand模块；将设备的上报数据信息按照通信协议中每个报文的功能码区分为不同的service，即WellWaterDeviceInfo（开机信息）模块与WellWaterTiming（定时上报）模块。 编写下行service下行命令在service中的书写格式如图3‑5所示。Commands数组里面存放若干个命令对象，每个命令对象包含CommandName命令的名称和paras命令携带的参数数组，以及responses命令回应数组。paras数组里面包含若干个参数对象。参数对象包含paraName等一系列属性。这每一个参数对象都对应通信协议报文中的一个属性。serviceType的值一定要与当前服务文件夹名称保持一致。 图3‑5 命令service 编写上行service上行属性service比命令service要简单，properties数组中存放的是设备上报上来的数据，每一个json对象对应通信协议报文中的一个属性。propertyName的值可以随意定义，dataType的值如不能根据通信协议中的默认参数值明显的判断该属性的数据类型，应找相关人员确认，否则解析将会出现数据错误。 打包Profile将WellMonitor_Chinastar_CSiTWLM05文件夹下的profile和service文件打包为zip格式，命名为WellMonitor_Chinastar_CSiTWLM05，并且压缩包内不能包含WellMonitor_Chinastar_CSiTWLM05文件夹这一层目录。 编解码开发使用eclipse配置本地maven仓库，并导入华为提供的demo工程。 修改pom.xml中的&lt;artifactId&gt;XXX&lt;/artifactId&gt;和&lt;Bundle-SymbolicName&gt;XXX&lt;/Bundle-SymbolicName&gt;命名规范：设备类型-厂商ID-设备型号，与Profile文件保持一致。如图3‑6、图3‑7所示。 图3‑6 pom修改厂商名称 图3‑7 pom修改厂商名称 修改ProtocolAdapterImpl.java中的厂商名称与设备型号，注意与Profile保持一致。如图3‑8所示。 图3‑8 修改Protocol文件 编写下行编码数据下行编码流程如图3‑9所示，通过获取OC平台发送过来的json数据，首先根据serviceId将对应数据保存到全局变量中，然后调用toByte方法，将各种类型的数据装换为16进制的比特数组。拼装成一条完整的报文并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 图3‑9 数据下行编码流程图 编写上行解码数据上行解码流程如图3‑10所示。通过获取OC平台发送过来的16进制比特数组格式数据，首先根据比特数组中的功能码（功能码在数据哪个位置，请从通信协议中查看），将不同服务对应的不同数据，根据通信协议将byte类型的属性转换为所需类型，保存到全局变量中，然后调用toJsonNode方法，拼装成一个Json对象并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 图3‑10 数据上行解码流程图 打包编解码打包编解码，即将该maven工程打包成jar文件。检查pom.xml中的&lt;packaging&gt;bundle&lt;/packaging&gt;值是否为bundle，不能为jar。以eclipse为例，在工程上右键选择RunAs然后选择Maven build…如图3‑11所示。 图3‑11 Mavenbuild 在Goals中输入clean package点击Run按钮，如图3‑12所示。 图3‑12 Mavenpackage 等待控制台出现BUILDSUCCESS，即可在当前项目的target目录下找到打包好的jar文件，如图3‑13所示，打包编解码完成。 图3‑13 Build 附录 点击显/隐内容 上行代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557package com.thrid.party.codec.demo;import java.util.Arrays;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ArrayNode;import com.fasterxml.jackson.databind.node.ObjectNode;public class ReportProcess &#123;// private String identifier;private String msgType = &quot;deviceReq&quot;;private int hasMore = 0;private int errcode = 0;// 在报文中表示报文类型的字段private byte bFunctionCode;// 开机信息功能码private static final byte DEVICE_POWER_ON = 0x01;// 数据上报功能码private static final byte DEVICE_DATA_REPORT = 0x02;// 应答报文功能码private static final byte DEVICE_REPLY = (byte) 0xAA;// 无后续数据private static final int NO_MORE = 0;private static final String REQUEST =&quot;deviceReq&quot;;private static final String RESPONSE =&quot;deviceRsp&quot;;private int identifier;private int protocolVersion;// 终端类型默认为12private int deviceType;private int iDeviceState = 0;// 终端压力阈值（默认未0），上行数据会对这个值进行覆盖private int distanceAlarmThreshold = 0;;// 终端定时上报时间 ，上行数据会对这个值进行覆盖private int iHeartBeatTime = 0;// 终端报警间隔时间，上行数据会对这个值进行覆盖private int iAlarmReportInterval = 0;private int iSampleInterval = 0;// 终端硬件版本，上行数据会对这个值进行覆盖private int iVersionHW = 1;// 终端软件版本，，上行数据会对这个值进行覆盖private int iVersionFW = 1;// 终端SN号，上行数据会对这个值进行覆盖private int iDeviceSN = 1;private int iNbiotState = 0;// 电池状态，上行数据会对这个值进行覆盖private int iBatteryState = 0;// 云端应答状态，上行数据会对这个值进行覆盖private int iAckState = 0;private int iGuardState = 0;// 报警状态 （默认为0不报警），在定时上报中会对这个值进行覆盖private int iAlarmState = 0;// 当前压力，在定时上报中会对这个值进行覆盖private int iCurPValue = 0;// 当前角度，在定时上报中会对这个值进行覆盖private int iBatteryVoltage = 3600;private int iBatteryCap;// 信号强度，在定时上报中会对这个值进行覆盖private int iSignalStrength = 0;// 信号覆盖等级，在定时上报中会对这个值进行覆盖private int iSignalECL = 0;// 信噪比，在定时上报中会对这个值进行覆盖private int iSignalSNR = 0;// 小区所在Id,在定时上报中会对这个值进行覆盖private int iCellId = 0;// 小区所在得PCI,在定时上报中会对这个值进行覆盖private int iSignalPCI = 0;// 温度，在定时上报中会对这个值进行覆盖// private int iTemperature = 0;// 终端回应设置信息时上发的错误码private int iResult = 0;private int mid = 0;private int curTilt = 0;private int bgTilt = 0;private int gasDensity = 0;private int alarmThreshold = 0;private int waterStatus = 0;private int deviceState = 0;private String strDevPostfix;private String imei;private String imsi;/\*\*\* \@param binaryData 设备发送给平台coap报文\* \@return\*/public ReportProcess(byte[] binaryData) &#123;binaryData = Utilty.getInstance().positionFormat(binaryData);protocolVersion = binaryData[0];bFunctionCode = binaryData[1];identifier = Utilty.getInstance().bytes2Int(binaryData, 2, 2);mid = Utilty.getInstance().bytes2Int(binaryData, 4, 2);Utilty.getInstance().mid = mid;Utilty.getInstance().functioncode = bFunctionCode;System.out.println(&quot;dingmingdong\\n&quot;);System.out.println(Utilty.getInstance().mid);System.out.println(identifier);if (bFunctionCode == DEVICE_POWER_ON) &#123;msgType = REQUEST;hasMore = NO_MORE;iDeviceSN = Utilty.getInstance().bytes2Int(binaryData,8, 4);deviceType = binaryData[12];// iGuardState = binaryData[5];iVersionHW = binaryData[13];iVersionFW = Utilty.getInstance().bytes2Int(binaryData,14, 4);//strDevPostfix = new String(binaryData, 14, 16);//iDeviceState = Utilty.getInstance().bytes2Int(binaryData,30, 2);iHeartBeatTime = Utilty.getInstance().bytes2Int(binaryData, 20, 2);iAlarmReportInterval = Utilty.getInstance().bytes2Int(binaryData, 22, 2);iSampleInterval = Utilty.getInstance().bytes2Int(binaryData, 24, 2);imei = new String(binaryData, 26, 16);imsi = new String(binaryData, 42, 16);alarmThreshold = Utilty.getInstance().bytes2Int(binaryData, 58, 2);//binArray用于存放状态码的二进制数字，由于binaryData[31]转换的二进制数组中目前未携带有用信息，不做解析// int[] binArray = Utilty.getInstance().byte2Binary(binaryData[30]);// iBatteryState = binArray[0];//iAckState = binArray[1];// iNbiotState = binArray[2];// iGuardState = binArray[3];// iAlarmState = binArray[4];// iDeviceState = binArray[5];// iBlueteethState = binArray[6];// strModuleVersion = new String(binaryData, 21, 20);&#125; else if( bFunctionCode == DEVICE_DATA_REPORT )&#123;msgType = REQUEST;hasMore = NO_MORE;iDeviceSN = Utilty.getInstance().bytes2Int(binaryData,8, 4);deviceState = Utilty.getInstance().bytes2Int(binaryData,12, 2);// iBatteryVoltage = Utilty.getInstance().bytes2Int(binaryData, 4, 2);iBatteryCap = Utilty.getInstance().bytes2Int(binaryData, 14, 1);iSignalStrength = Utilty.getInstance().bytes2Int(binaryData, 16, 4);iSignalECL = binaryData[20];iSignalSNR = binaryData[21];iCellId = Utilty.getInstance().bytes2Int(binaryData, 22, 4);iSignalPCI = Utilty.getInstance().bytes2Int(binaryData, 26, 2);bgTilt = Utilty.getInstance().bytes2Int(binaryData, 28, 2);curTilt = Utilty.getInstance().bytes2Int(binaryData, 30, 2);gasDensity = Utilty.getInstance().bytes2Int(binaryData, 32, 2);waterStatus = Utilty.getInstance().bytes2Int(binaryData, 34, 2);&#125;else if (bFunctionCode == DEVICE_REPLY) &#123;msgType = RESPONSE;// 在华为的API中规定 ： errcode 为0表示成功，1表示失败 ；但下位机协议中规定错误码为0无错误，1超范围，2检验错误；在profile文件中终端的应答应当包含一个int型的result参数,// 为了避免数据损失，在这里将终端的错误码放在result中，而errcode按照华为的API规定，只要下位机的错误码不为零，就认为失败，即在error中装入1.errcode = binaryData[8]==0?0:1;iResult = binaryData[8];&#125; else &#123;return;&#125;&#125;public ObjectNode toJsonNode() &#123;try &#123;//组装body体ObjectMapper mapper = new ObjectMapper();ObjectNode root = mapper.createObjectNode();String s = Integer.toString(this.identifier);root.put(&quot;identifier&quot;, s);System.out.println(s);root.put(&quot;msgType&quot;, this.msgType);//根据msgType字段组装消息体if (this.msgType.equals(REQUEST) &amp;&amp; bFunctionCode == DEVICE_POWER_ON) &#123;root.put(&quot;hasMore&quot;, this.hasMore);ArrayNode arrynode = mapper.createArrayNode();// serviceId = Basic 数据组装ObjectNode BasicNode = mapper.createObjectNode();BasicNode.put(&quot;serviceId&quot;, &quot;Basic&quot;);ObjectNode BasicData = mapper.createObjectNode();BasicData.put(&quot;heartBeatTime&quot;, this.iHeartBeatTime);BasicData.put(&quot;alarmReportInterval&quot;, this.iAlarmReportInterval);BasicData.put(&quot;sampleInterval&quot;, this.iSampleInterval);BasicData.put(&quot;mid&quot;, this.mid);//hydrantBasicData.put(&quot;tiltAlarmThreshold&quot;, this.iTiltAlarmThreshold);BasicNode.put(&quot;serviceData&quot;,BasicData);arrynode.add(BasicNode);// serviceId = Tilt 数据组装ObjectNode TiltNode = mapper.createObjectNode();TiltNode.put(&quot;serviceId&quot;, &quot;Tilt&quot;);ObjectNode TiltData = mapper.createObjectNode();TiltData.put(&quot;alarmThreshold&quot;, this.alarmThreshold);//hydrantBasicData.put(&quot;tiltAlarmThreshold&quot;, this.iTiltAlarmThreshold);TiltNode.put(&quot;serviceData&quot;,TiltData);arrynode.add(TiltNode);// serviceId = DeviceInfo 数据组装ObjectNode deviceInfoNode = mapper.createObjectNode();deviceInfoNode.put(&quot;serviceId&quot;, &quot;DeviceInfo&quot;);ObjectNode deviceInfoData = mapper.createObjectNode();deviceInfoData.put(&quot;deviceType&quot;, this.deviceType);deviceInfoData.put(&quot;versionHW&quot;, this.iVersionHW);deviceInfoData.put(&quot;versionFW&quot;, this.iVersionFW);deviceInfoData.put(&quot;deviceSN&quot;, this.iDeviceSN);deviceInfoData.put(&quot;imei&quot;, this.imei);deviceInfoData.put(&quot;imsi&quot;, this.imsi);deviceInfoData.put(&quot;deviceID&quot;, this.identifier);deviceInfoData.put(&quot;protocolVersion&quot;, this.protocolVersion);//deviceInfoData.put(&quot;moduleVersion&quot;, this.strModuleVersion);deviceInfoNode.put(&quot;serviceData&quot;,deviceInfoData);arrynode.add(deviceInfoNode);root.put(&quot;data&quot;, arrynode);&#125; else if(this.msgType.equals(REQUEST) &amp;&amp; bFunctionCode == DEVICE_DATA_REPORT)&#123;root.put(&quot;hasMore&quot;, this.hasMore);ArrayNode arrynode = mapper.createArrayNode();// serviceId = Basic 数据组装ObjectNode BasicNode = mapper.createObjectNode();BasicNode.put(&quot;serviceId&quot;, &quot;Basic&quot;);ObjectNode BasicData = mapper.createObjectNode();//BasicData.put(&quot;batteryVoltage&quot;, this.iBatteryVoltage);BasicData.put(&quot;batteryLevel&quot;,this.iBatteryCap);BasicData.put(&quot;deviceState&quot;, this.deviceState);BasicData.put(&quot;mid&quot;, this.mid);BasicNode.put(&quot;serviceData&quot;,BasicData);arrynode.add(BasicNode);// serviceId = Connectivity 数据组装ObjectNode connectivityNode = mapper.createObjectNode();ObjectNode connectivityData = mapper.createObjectNode();connectivityData.put(&quot;signalStrength&quot;, this.iSignalStrength);connectivityData.put(&quot;cellId&quot;, this.iCellId);connectivityData.put(&quot;signalECL&quot;, this.iSignalECL);connectivityData.put(&quot;signalPCI&quot;, this.iSignalPCI);connectivityData.put(&quot;signalSNR&quot;, this.iSignalSNR);connectivityNode.put(&quot;serviceId&quot;, &quot;Connectivity&quot;);connectivityNode.put(&quot;serviceData&quot;,connectivityData);arrynode.add(connectivityNode);// serviceId = Tilt 数据组装ObjectNode tiltNode = mapper.createObjectNode();ObjectNode tiltData = mapper.createObjectNode();tiltData.put(&quot;curTilt&quot;, this.curTilt);tiltData.put(&quot;bgTilt&quot;, this.bgTilt);tiltData.put(&quot;gasDensity&quot;, this.gasDensity);tiltData.put(&quot;waterStatus&quot;, this.waterStatus);tiltNode.put(&quot;serviceId&quot;, &quot;Tilt&quot;);tiltNode.put(&quot;serviceData&quot;,tiltData);arrynode.add(tiltNode);// serviceId = DeviceInfo 数据组装ObjectNode deviceInfoNode = mapper.createObjectNode();deviceInfoNode.put(&quot;serviceId&quot;, &quot;DeviceInfo&quot;);ObjectNode deviceInfoData = mapper.createObjectNode();// deviceInfoData.put(&quot;deviceType&quot;, this.deviceType);// deviceInfoData.put(&quot;versionHW&quot;, this.iVersionHW);// deviceInfoData.put(&quot;versionFW&quot;, this.iVersionFW);deviceInfoData.put(&quot;deviceSN&quot;, this.iDeviceSN);// deviceInfoData.put(&quot;imei&quot;, this.imei);// deviceInfoData.put(&quot;imsi&quot;, this.imsi);deviceInfoData.put(&quot;deviceID&quot;, this.identifier);deviceInfoData.put(&quot;protocolVersion&quot;, this.protocolVersion);//deviceInfoData.put(&quot;moduleVersion&quot;, this.strModuleVersion);deviceInfoNode.put(&quot;serviceData&quot;,deviceInfoData);arrynode.add(deviceInfoNode);// serviceId = DeviceState 数据组装// ObjectNode deviceStateNode = mapper.createObjectNode();// ObjectNode deviceStateData = mapper.createObjectNode();//deviceStateData.put(&quot;guardState&quot;, this.iGuardState);//deviceStateData.put(&quot;alarmState&quot;, this.iAlarmState);//deviceStateData.put(&quot;moduleState&quot;, this.iNbiotState);//deviceStateData.put(&quot;batteryState&quot;, this.iBatteryState);//deviceStateData.put(&quot;ackState&quot;, this.iAckState);//deviceStateNode.put(&quot;serviceId&quot;, &quot;DeviceState&quot;);//deviceStateNode.put(&quot;serviceData&quot;,deviceStateData);//arrynode.add(deviceStateNode);// serviceId = Temperature 数据组装// ObjectNode temperatureNode = mapper.createObjectNode();// ObjectNode temperatureData = mapper.createObjectNode();// temperatureData.put(&quot;temperature&quot;, this.iTemperature);// temperatureNode.put(&quot;serviceId&quot;, &quot;Temperature&quot;);// temperatureNode.put(&quot;serviceData&quot;,temperatureData);// arrynode.add(temperatureNode);root.put(&quot;data&quot;, arrynode);&#125;else &#123;root.put(&quot;mid&quot;, this.mid);root.put(&quot;errcode&quot;, this.errcode);//组装body体，只能为ObjectNode对象ObjectNode body = mapper.createObjectNode();body.put(&quot;result&quot;, iResult);root.put(&quot;body&quot;, body);&#125;return root;&#125; catch (Exception e) &#123;e.printStackTrace();return null;&#125;&#125;&#125; 下行数据代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725package com.thrid.party.codec.demo;import java.util.Arrays;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.node.ObjectNode;public class CmdProcess &#123;private String identifier = &quot;0&quot;;private int intIdentifier = 0;private String msgType = &quot;deviceReq&quot;;private String serviceId = &quot;Brightness&quot;;private int hasMore = 0;private static int mid = 0;private int errcode = 0;private JsonNode paras;private String cmd = &quot;REREAD&quot;;// 云端回应private static final byte B_CMD_RESPONSE = (byte) 0xAA;// 配置信息private static final byte B_TO_CONFIGURATION = 0x03;// 复位命令private static final byte B_TO_RESET = 0x04;// 布防/撤防private static final byte B_TO_GUARD_OR_WITHDRAW = 0x05;// 忽略本次报警private static final byte B_TO_IGNORE = 0x06;// 重新读取开机信息private static final byte B_TO_REREAD = 0x07;private static final byte B_TO_FACTORYDEFAULT = 0x09;private static final byte B_TO_SAMPLE_BGTILT_RSP = 10;// 在报文中表示报文类型的字段private byte bFunctionCode;// 在报文中表示信息长度的字段private byte dataLength;// 将要配置的新IDprivate int iNewId;// 上报时间private int iHeartBeatTime;// 报警间隔private int iAlarmReportInterval;private int iSampleInterval;private byte protocolVersion = 1;// IP设置private int iAddressIP;// 端口号设置private int iAddressPort;// 压力报警阈值private int distanceAlarmThreshold;private int reportmid;private int iPressureAlarmLowThreshold;private int iPressureAlarmUpDiff;private int iPressureAlarmLowDiff;// 倾斜角报警阈值// private int iTiltAlarmThreshold;// 在命令为GUARD_OR_WITHDRAW时是要布防还是撤防： 1表示布防，0表示撤防private byte bGuardOrWithdraw = 1;// 用于存储平台自动应答时返回的request字段，该字段即设备的上行数据byte[] deviceRequest;public CmdProcess() &#123;&#125;public CmdProcess(ObjectNode input) &#123;try &#123;try &#123;this.identifier = input.get(&quot;identifier&quot;).asText();&#125; catch (Exception e) &#123;&#125;mid = mid + 1;this.msgType = input.get(&quot;msgType&quot;).asText();// this.mid = input.get(&quot;mid&quot;).asInt();//未使用mid在此处不能放出来，否则会造成程序异常if (msgType.equals(&quot;cloudRsp&quot;)) &#123;this.errcode = input.get(&quot;errcode&quot;).asInt();deviceRequest = input.get(&quot;request&quot;).binaryValue();byte[] identifierBytes = &#123;deviceRequest[3],deviceRequest[2]&#125;;intIdentifier = Utilty.getInstance().bytes2Int(identifierBytes, 0, 2);byte[] midBytes = &#123;deviceRequest[5],deviceRequest[4]&#125;;reportmid = Utilty.getInstance().bytes2Int(midBytes, 0, 2);bFunctionCode = B_CMD_RESPONSE;dataLength = 0x01;&#125; else &#123;this.cmd = input.get(&quot;cmd&quot;).asText();switch (this.cmd) &#123;case &quot;CONFIGURATION&quot;:bFunctionCode = B_TO_CONFIGURATION;dataLength = 22;this.paras = input.get(&quot;paras&quot;);iNewId = this.paras.get(&quot;newId&quot;).asInt();iHeartBeatTime = this.paras.get(&quot;heartBeatTime&quot;).asInt();iAlarmReportInterval = this.paras.get(&quot;alarmReportInterval&quot;).asInt();iSampleInterval = this.paras.get(&quot;sampleInterval&quot;).asInt();iAddressIP = this.paras.get(&quot;addressIP&quot;).asInt();iAddressPort = this.paras.get(&quot;addressPort&quot;).asInt();distanceAlarmThreshold = this.paras.get(&quot;distanceAlarmThreshold&quot;).asInt();//iPressureAlarmLowThreshold =this.paras.get(&quot;pressureAlarmLowThreshold&quot;).asInt();//iPressureAlarmUpDiff = this.paras.get(&quot;pressureAlarmUpDiff&quot;).asInt();//iPressureAlarmLowDiff = this.paras.get(&quot;pressureAlarmLowDiff&quot;).asInt();//iTiltAlarmThreshold = this.paras.get(&quot;tiltAlarmThreshold&quot;).asInt();break;case &quot;RESET&quot;:bFunctionCode = B_TO_RESET;dataLength = 0x00;break;case &quot;SAMPLE_BGTILT_RSP&quot;:bFunctionCode = B_TO_SAMPLE_BGTILT_RSP;dataLength = 0x00;break;case &quot;GUARD_OR_WITHDRAW&quot;:bFunctionCode = B_TO_GUARD_OR_WITHDRAW;dataLength = 0x01;this.paras = input.get(&quot;paras&quot;);bGuardOrWithdraw = (byte) this.paras.get(&quot;guardOrWithdraw&quot;).asInt();break;case &quot;IGNORE&quot;:bFunctionCode = B_TO_IGNORE;dataLength = 0x00;break;case &quot;REREAD&quot;:bFunctionCode = B_TO_REREAD;dataLength = 0x00;break;case &quot;FACTORYDEFAULT&quot;:bFunctionCode = B_TO_FACTORYDEFAULT;dataLength = 0x00;break;default:break;&#125;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;public byte[] toByte() &#123;try &#123;if (this.msgType.equals(&quot;cloudReq&quot;)) &#123;byte[] bytesRead = null;int idid = 0;try &#123;idid = Integer.parseInt(this.identifier);&#125; catch (NumberFormatException e) &#123;e.printStackTrace();&#125;switch (this.cmd) &#123;case &quot;CONFIGURATION&quot;:&#123;//iNewId = this.paras.get(&quot;newId&quot;).asInt();//iHeartBeatTime = this.paras.get(&quot;heartBeatTime&quot;).asInt();//iAlarmReportInterval = this.paras.get(&quot;alarmReportInterval&quot;).asInt();//iAddressIP = this.paras.get(&quot;addressIP&quot;).asInt();//iAddressPort = this.paras.get(&quot;addressPort&quot;).asInt();//iPressureAlarmThreshold = this.paras.get(&quot;pressureAlarmThreshold&quot;).asInt();//iTiltAlarmThreshold = this.paras.get(&quot;tiltAlarmThreshold&quot;).asInt();dataLength = 18;bytesRead= new byte[28];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;//byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNewId = Utilty.getInstance().int2Bytes(this.iNewId, 2);bytesRead[8] = bytesNewId[1];bytesRead[9] = bytesNewId[0];byte[] bytesHeartBeatTime = Utilty.getInstance().int2Bytes(this.iHeartBeatTime,2);bytesRead[10] = bytesHeartBeatTime[1];bytesRead[11] = bytesHeartBeatTime[0];byte[] bytesAlarmReportInterval =Utilty.getInstance().int2Bytes(this.iAlarmReportInterval, 2);bytesRead[12] = bytesAlarmReportInterval[1];bytesRead[13] = bytesAlarmReportInterval[0];byte[] bytesSampleInterval =Utilty.getInstance().int2Bytes(this.iSampleInterval, 2);bytesRead[14] = bytesSampleInterval[1];bytesRead[15] = bytesSampleInterval[0];byte[] bytesAddressIP = Utilty.getInstance().int2Bytes(this.iAddressIP, 4);bytesRead[16] = bytesAddressIP[3];bytesRead[17] = bytesAddressIP[2];bytesRead[18] = bytesAddressIP[1];bytesRead[19] = bytesAddressIP[0];byte[] bytesAddressPort = Utilty.getInstance().int2Bytes(this.iAddressPort, 2);bytesRead[20] = bytesAddressPort[1];bytesRead[21] = bytesAddressPort[0];byte[] bytesAlarmThreshold =Utilty.getInstance().int2Bytes(this.distanceAlarmThreshold, 2);bytesRead[22] = bytesAlarmThreshold[1];bytesRead[23] = bytesAlarmThreshold[0];bytesRead[24] = 0;bytesRead[25] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[26] = bytesCRC[1];bytesRead[27] = bytesCRC[0];break;&#125;case &quot;RESET&quot;:&#123;bFunctionCode = B_TO_RESET;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;GUARD_OR_WITHDRAW&quot;:&#123;bFunctionCode = B_TO_GUARD_OR_WITHDRAW;bGuardOrWithdraw = (byte) this.paras.get(&quot;guardOrWithdraw&quot;).asInt();dataLength = 0x02;bytesRead= new byte[12];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;bytesRead[8] = bGuardOrWithdraw;bytesRead[9] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[10] = bytesCRC[1];bytesRead[11] = bytesCRC[0];break;&#125;case &quot;IGNORE&quot;:&#123;bFunctionCode = B_TO_IGNORE;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;SAMPLE_BGTILT_RSP&quot;:&#123;bFunctionCode = B_TO_SAMPLE_BGTILT_RSP;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;FACTORYDEFAULT&quot;:&#123;bFunctionCode = B_TO_FACTORYDEFAULT;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;REREAD&quot;:&#123;bFunctionCode = B_TO_REREAD;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;default:break;&#125;return bytesRead;&#125; else if (this.msgType.equals(&quot;cloudRsp&quot;)) &#123;byte[] bytesRead = new byte[12];/\*\*平台对上行数据的自动应答过程中，并不会每次都去调用带参的构造方法（猜测），所以数据的具体组装需要在toByte方法中进行以保证回复及下发的稳定性\*/bFunctionCode = B_CMD_RESPONSE;dataLength = 2;/\*\*在此对捕获的设备命令进行校验，如果无错误，将errcode置为0，若校验错误，将其置为2\*/boolean isValide = false;if(deviceRequest != null)&#123;isValide = Utilty.getInstance().isValid(deviceRequest);&#125;bytesRead= new byte[12];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = B_CMD_RESPONSE;//byte[] bytesId = Utilty.getInstance().int2Bytes(this.intIdentifier, 2);;bytesRead[2] = deviceRequest[2];bytesRead[3] = deviceRequest[3];//byte[] bytesmid = Utilty.getInstance().int2Bytes(this.reportmid, 2);bytesRead[4] = deviceRequest[4];bytesRead[5] = deviceRequest[5];bytesRead[6] = dataLength;bytesRead[7] = 0;bytesRead[8] = 0;//(byte) (isValide?0:2);bytesRead[9] = (byte)Utilty.getInstance().functioncode;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[10] = bytesCRC[1];bytesRead[11] = bytesCRC[0];return bytesRead;&#125;return null;&#125; catch (Exception e) &#123;// TODO: handle exceptione.printStackTrace();return null;&#125;&#125;&#125;]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>编解码</tag>
        <tag>OceanConnect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty组件和设计]]></title>
    <url>%2FNetty%2FNetty%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Netty的组件和设计Channel 接口 在基于Java的网络编程中，其基本的构造是class socket。Netty的Channel接口所提供的api，大大的降低了直接使用Socket类的复杂性。 EventLoop 接口 EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。 一个EventLoopGroup包含一个或者多个EventLoop； 一个EventLoop在它的生命周期内只和一个Thread绑定； 所有由EventLoop处理的 I/O 事件都将在它专有的Thread上被处理； 一个Channel在它的生命周期内只注册于一个EventLoop； 一个EventLoop可能会被分配给一个或多个Channel。 ChannelFuture 接口 Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会 立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了 ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以 便在某个操作完成时（无论是否成功）得到通知。 ChannelHandler 接口 充当了所有 处理入站和出站数据的应用程序逻辑的容器。 ChannelPipeline 接口 ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站 和出站事件流的 API。当 Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。 ChannelPipeline中存放的是ChannelHandler链，一条数据可以经过多个ChannelHandler进行处理，类似拦截器。 引导 Bootstrap 客户端配置 ServerBootstrap 服务端配置 引导一个客户端只需要一个 EventLoopGroup，但是一个 ServerBootstrap则需要两个（也可以是同一个实例）。 因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务 器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传 入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
