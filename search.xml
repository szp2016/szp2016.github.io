<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IO吞吐量与IO延迟]]></title>
    <url>%2Funcategorized%2FIO%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%8EIO%E5%BB%B6%E8%BF%9F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[块IO层]]></title>
    <url>%2Funcategorized%2F%E5%9D%97IO%E5%B1%82%2F</url>
    <content type="text"><![CDATA[Linux中设备分为字符设备，块设备，网络设备三大类。对于字符设备与块设备区别在于能否随机访问数据，对于字符设备键盘来说，键盘驱动程序会按照和用户输入完全相同的顺序读取字符，并且得到一个字符流。但是对于块设备硬盘来说，硬盘驱动程序可能需要读取磁盘上任意块的内容，这些块不一定是连续的，所以说可以被随机访问。 所以事实上内核不必提供一个专门的子系统来管理字符设备，但是对块设备的管理却必须要有一个专门的提供服务的子系统。不仅仅是因为块设备的复杂性远远高于字符设备，更重要的原因是块设备对执行性能的要求很高﹔对硬盘每多一份利用都会对整个系统的性能带来提升。另外，我们将会看到，块设备的复杂性会为这种优化留下很大的施展空间。对块设备和块设备的请求进行管理，在内核中称作块IO层。 块设备块设备中最小的可寻址单元为扇区，扇区最常见的大小为512字节。块是文件系统的一种抽象–只能基于块来访问文件系统。虽然物理磁盘寻址是按照扇区级进行的，但是内核执行的所有磁盘操作都是按照块进行的。内核（对有扇区的硬件设备）要求块大小是2的整数倍，而且不能超过一个页的长度。所以，对块大小的最终要求是，必须是扇区大小的2的整数倍，并且要小于页面大小。所以通常块大小是512KB、1KB或4KB。 块设备基本操作单元缓冲区和缓冲区头当一个块被调入内存时（也就是说，在读人后或等待写出时)，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示。前面提到过，块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。由于内核处理数据时需要一些相关的控制信息（比如块属于哪一个块设备，块对应于哪个缓冲区等)，所以每一个缓冲区都有一个对应的描述符。该描述符用buffer_head结构体表示，称作缓冲区头，在文件&lt;linux/buffer_head.h&gt;（基于内核4.1.14）中定义，它包含了内核操作缓冲区所需要的全部信息。 1234567891011121314151617struct buffer_head &#123; unsigned long b_state; /* 缓冲区状态标志 */ struct buffer_head *b_this_page;/* 页面中的缓冲区，递归列表 */ struct page *b_page; /* 存储该缓冲区的页面 */ sector_t b_blocknr; /* 起始块号 */ size_t b_size; /* 块大小 */ char *b_data; /* 块起始位置，位于b_page中所指明的页面的某个位置上 */ struct block_device *b_bdev; /* 相关联的块设备*/ bh_end_io_t *b_end_io; /* I/O 完成方法 */ void *b_private; /* reserved for b_end_io */ struct list_head b_assoc_buffers; /* associated with another mapping */ struct address_space *b_assoc_map; /* mapping this buffer is associated with */ atomic_t b_count; /* 该缓冲区使用计数 */&#125;; b_count域表示缓冲区的使用记数，可通过两个定义在文件&lt;linux/buffer_head.h&gt;中的内联函数对此域进行增减。 12345678910static inline void get_bh(struct buffer_head *bh)&#123; atomic_inc(&amp;bh-&gt;b_count);&#125;static inline void put_bh(struct buffer_head *bh)&#123; smp_mb__before_atomic(); atomic_dec(&amp;bh-&gt;b_count);&#125; 在操作缓冲区头之前，应该先使用get_bh()函数增加缓冲区头的引用计数，确保该缓冲区头不会再被分配出去;当完成对缓冲区头的操作之后，还必须使用put_bh()函数减少引用计数。 与缓冲区对应的磁盘物理块由b__blocknr-th域索引，该值是b__bdev域指明的块设备中的逻辑块号。与缓冲区对应的内存物理页由b_ page 域表示，另外，b_data域直接指向相应的块(它位于b_ page域所指明的页面中的某个位置上)，块的大小由b_size 域表示，所以块在内存中的起始位置在b_data处，结束位置在(b_data + b_size)处。 在2.6内核以前，将缓冲区作为I/O操作单元带来了两个弊端。 缓冲区头是一个很大且不易控制的数据结构体(现在是缩减过的了)，而且缓冲区头对数据的操作既不方便也不清晰。对内核来说，它更倾向于操作页面结构，因为页面操作起来更为简便，同时效率也高。 缓冲区头仅能描述单个缓冲区，当作为所有I/O的容器使用时，缓冲区头会促使内核把对大块数据的I/O操作(比如写操作)分解为对多个buffer_head结构体进行操作。这样做必然会造成不必要的负担和空间浪费。所以2.5开发版内核的主要目标就是为块I/O操作引入一种新型、灵活并且轻量级的容器，bio结构体。 bio结构体目前内核中块I/O操作的基本容器由bio结构体表示，它定义在文件&lt;linux/blk_types.h&gt;中。该结构体代表了正在现场的(活动的)以片断(segment)链表形式组织的块I/O操作，对缓冲区进行了封装，使用一个结构体数组存储多个缓冲区片段。结构体数组的一个元素是一小块连续的内存缓冲区，整个结构体数组表示了一个完整的缓冲区。这样的话，就不需要保证单个缓冲区一定要连续。 所以通过用片段来描述缓冲区，即使一个缓冲区分散在内存的多个位置上，bio结构体也能对内核保证I/O操作的执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct bio &#123; struct bio *bi_next; /* request queue link */ struct gendisk *bi_disk; unsigned int bi_opf; /* bottom bits req flags, * top bits REQ_OP. Use * accessors. */ unsigned short bi_flags; /* status, etc and bvec pool number */ unsigned short bi_ioprio; unsigned short bi_write_hint; blk_status_t bi_status; u8 bi_partno; /* Number of segments in this BIO after * physical address coalescing is performed. */ unsigned int bi_phys_segments; /* * To keep track of the max segment size, we account for the * sizes of the first and last mergeable segments in this bio. */ unsigned int bi_seg_front_size; unsigned int bi_seg_back_size; struct bvec_iter bi_iter; atomic_t __bi_remaining; bio_end_io_t *bi_end_io; void *bi_private;#ifdef CONFIG_BLK_CGROUP /* * Optional ioc and css associated with this bio. Put on bio * release. Read comment on top of bio_associate_current(). */ struct io_context *bi_ioc; struct cgroup_subsys_state *bi_css;#ifdef CONFIG_BLK_DEV_THROTTLING_LOW void *bi_cg_private; struct blk_issue_stat bi_issue_stat;#endif#endif union &#123;#if defined(CONFIG_BLK_DEV_INTEGRITY) struct bio_integrity_payload *bi_integrity; /* data integrity */#endif &#125;; unsigned short bi_vcnt; /* how many bio_vec's */ /* * Everything starting with bi_max_vecs will be preserved by bio_reset() */ unsigned short bi_max_vecs; /* max bvl_vecs we can hold */ atomic_t __bi_cnt; /* pin count */ struct bio_vec *bi_io_vec; /* IO向量结构体数组 */ struct bio_set *bi_pool; /* * We can inline a number of vecs at the end of the bio, to avoid * double allocations for a small number of bio_vecs. This member * MUST obviously be kept at the very end of the bio. */ struct bio_vec bi_inline_vecs[0];&#125;; 使用bio结构体的目的主要是代表正在现场执行的I/O操作，所以该结构体中的主要城都是用来管理相关信息的，其中最重要的几个域是bi_io_vecs、bi_vcnt。 下图显示了bio结构体及其他结构体之间的关系。 I/O向量bi_io_vec指针指向一个 bio_vec 结构体数组，该结构体链表包含了一个特定IO操作所需要使用到的所有片段。每个bio_vec结构都是一个形式为&lt;page,offset,len&gt;的向量，它描述的是一个特定的片段:片段所在的物理页、块在物理页中的偏移位置、从给定偏移量开始的块长度。整个bio_io_vec结构体数组表示了一个完整的缓冲区。bio_vec结构定义在&lt;linux/bvec.h&gt; 文件中: 12345678struct bio_vec &#123; /*指向该缓冲区片段所在的页面*/ struct page *bv_page; /* 缓冲区片段以字节为单位的长度*/ unsigned int bv_len; /*该缓冲区片段在物理页面的偏移位置*/ unsigned int bv_offset;&#125;; 总而言之，每一个块I0请求都通过一个bio结构体表示。每个请求包含一个或多个块，这些块存储在bio_vec 结构体数组中。这些结构体描述了每个片段在物理页中的实际位置，并且像向量一样被组织在一起。I/O 操作的第一个片段由b_io_vec结构体所指，其他的片段在其后依次放置，共有bi_vcnt个片段。当块I/O层开始执行请求、需要使用各个片段时，bi jidx 域会不断更新，从而总指向当前片段。 bi_cnt 域记录bio结构体的使用计数，如果该域值减为0，就应该撤销该bio结构体，并释放它占用的内存。通过下面两个函数管理使用计数。 123456789101112131415static inline void bio_get(struct bio *bio)&#123; bio-&gt;bi_flags |= (1 &lt;&lt; BIO_REFFED); smp_mb__before_atomic(); atomic_inc(&amp;bio-&gt;__bi_cnt);&#125;static inline void bio_cnt_set(struct bio *bio, unsigned int count)&#123; if (count != 1) &#123; bio-&gt;bi_flags |= (1 &lt;&lt; BIO_REFFED); smp_mb(); &#125; atomic_set(&amp;bio-&gt;__bi_cnt, count);&#125; 前者增加使用计数，后者减少使用计数(如果计数减到0,则撤销bio结构体)。在操作正在活动的bio结构体时，-定要首先增加它的使用计数，以免在操作过程中该bio结构体被释放;相反在操作完毕后，要减少使用计数。 请求队列块设备将它们挂起的块I/O请求保存在请求队列中，该队列由reques_queue结构体表示，定义在文件&lt;linux/blkdev.h&gt;中，包含一个双向请求链表以及相关控制信息。通过内核中像文件系统这样高层的代码将请求加入到队列中。请求队列只要不为空，队列对应的块设备驱动程序就会从队列头获取请求，然后将其送入对应的块设备上去。请求队列表中的每一项都是一个单独的请求，由reques结构体表示。 队列中的请求由结构体requcst 表示，它定义在文件&lt;linux/blkdev.h&gt;中。因为一个请求可能要操作多个连续的磁盘块，所以每个请求可以由多个bio结构体组成。注意，虽然在磁盘上的块必须连续，但是在内存中这些块并不一定要连续，每一个bio结构体都可以描述多个片段(回忆一下，片段是内存中连续的小区域)，而每个请求也可以包含多个bio结构体。 I/O调度程序I/O调度程序虚拟块设备给多个磁盘请求，以便降低磁盘寻址时间，确保磁盘性能的最优化。]]></content>
  </entry>
  <entry>
    <title><![CDATA[进程IO吞吐量与IO延迟]]></title>
    <url>%2Funcategorized%2F%E8%BF%9B%E7%A8%8BIO%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%8EIO%E5%BB%B6%E8%BF%9F%2F</url>
    <content type="text"><![CDATA[I/OI/O 的概念，从字义来理解就是输入输出。操作系统从上层到底层，各个层次之间均存在 I/O。比如，CPU 有 I/O，内存有 I/O, VMM 有 I/O, 底层磁盘上也有 I/O，这是广义上的 I/O。通常来讲，一个上层的 I/O 可能会产生针对磁盘的多个 I/O，也就是说，上层的 I/O 是稀疏的，下层的 I/O 是密集的。 Linux三大设备类型字符设备字符设备指能够像字节流串行顺序依次进行访问的设备，对它的读写是以字节为单位。字符设备的上层没有磁盘文件系统，所以字符设备的file_operations成员函数就直接由字符设备驱动提供（一般字符设备都会实现相应的fops集），因此file_operations 也就成为了字符设备驱动的核心。 特点： 一个字节一个字节读写的设备 读取数据需要按照先后数据（顺序读取） 每个字符设备在/dev目录下对应一个设备文件，linux用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备。 常见的字符设备有鼠标、键盘、串口、控制台等 块设备块设备以数据块的形式存放数据，如NAND Flash以页为单位存储数据，并采用mount方式挂载块设备。 块设备必须能够随机存取(random access)，字符设备则没有这个要求。 块设备除了给内核提供和字符设备一样的接口外，还提供了专门面向块设备的接口，块设备的接口必须支持挂装文件系统，通过此接口，块设备能够容纳文件系统，因此应用程序一般通过文件系统来访问块设备上的内容，而不是直接和设备打交道。 对于块设备而言，上层ext2,jiffs2,fat等文件系统会 实现针对VFS的file_opertations成员函数，所以设备驱动层将看不到file_opeations的存在。磁盘文件系统和设备驱动会将对磁盘上文件的访问转换成对磁盘上柱面和扇区的访问。 特点： 数据以固定长度进行传输，比如512K 从设备的任意位置（可跳）读取，但实际上，块设备会读一定长度的内容，而只返回用户要求访问的内容，所以随机访问实际上还是读了全部内容。 块设备包括硬盘、磁盘、U盘和SD卡等 每个块设备在/dev目录下对应一个设备文件，linux用户程序可以通过设备文件（或称设备节点）来使用驱动程序操作块设备。 块设备可以容纳文件系统，所以一般都通过文件系统来访问，而不是/dev设备节点。 网络设备 虽然在Linux系统存在一句话叫一切皆文件，无论是各种文本文件还是具体的硬件设备（硬件由设备文件来实现相应）。但是网络设备在Linux内核中却是唯一不体现一切皆设备思想的驱动架构，因为网络设备使用套接字来实现网数据的接受和发送。 网络设备驱动不同于字符设备和块设备，不在/dev下以文件节点代表，而是通过单独的网络接口来代表。 特点： 网络接口没有像字符设备和块设备一样的设备号和/dev设备节点，只有接口名，如eth0,eth1 通过socket操作，而不是open read write I/O子系统架构 上图概括了一次磁盘 write 操作的过程，假设文件已经被从磁盘中读入了 page cache 中 一个用户进程通过 write() 系统调用发起写请求 内核更新对应的 page cache pdflush 内核线程将 page cache 写入至磁盘中 文件系统层将每一个 block buffer 存放为一个 bio 结构体，并向块设备层提交一个写请求 块设备层从上层接受到请求，执行 IO 调度操作，并将请求放入IO 请求队列中 设备驱动（如 SCSI 或其他设备驱动）完成写操作 磁盘设备固件执行对应的硬件操作，如磁盘的旋转，寻道等，数据被写入到磁盘扇区中 Block LayerBlock layer 处理所有和块设备相关的操作。block layer 最关键是数据结构是 bio 结构体。bio 结构体是 file system layer 到 block layer 的接口。 当执行一个写操作时，文件系统层将数据写入 page cache（由 block buffer 组成），将连续的块放到一起，组成 bio 结构体，然后将 bio 送至 block layer。 block layer 处理 bio 请求，并将这些请求链接成一个队列，称作 IO 请求队列，这个连接的操作就称作 IO 调度（也叫 IO elevator 即电梯算法）. IO schedulerIO 调度器的总体目标是减少磁盘的寻道时间（因此调度器都是针对机械硬盘进行优化的），IO 调度器通过两种方式来减少磁盘寻道：合并和排序。 合并即当两个或多个 IO 请求的是相邻的磁盘扇区，那么就将这些请求合并为一个请求。通过合并请求，多个 IO 请求只需要向磁盘发送一个请求指令，减少了磁盘的开销。 排序就是将不能合并的 IO 请求，根据请求磁盘扇区的顺序，在请求队列中进行排序，使得磁头可以按照磁盘的旋转顺序的完成 IO 操作，可以减小磁盘的寻道次数。 调度器的算法和电梯运行的策略相似，因此 IO 调度器也被称作 IO 电梯( IO Elevator )。由于对请求进行了重排，一部分的请求可能会被延迟，以提升整体的性能。 Linux 2.4 只使用了一种通用的 IO 算法。到 Linux 2.6 实现了 4 种 IO 调度模型，其中 anticipatory 在 2.6.33 中被移除。 I/O性能评价指标IOPS每秒的输入输出量(或读写次数)，也就是在一秒内，磁盘进行多少次 I/O 读写。是衡量磁盘性能的主要指标之一。 吞吐量指单位时间内可以成功传输的数据数量。即磁盘写入加上读出的数据的大小。吞吐量等于IOPS乘以每次IO大小。 使用率使用率，是指磁盘处理I/O的时间百分比。过高的使用率(比如超过80% ) , 通常意味着磁盘I/O存在性能瓶颈。 饱和度饱和度，是指磁盘处理I/O的繁忙程度。过高的饱和度,意味着磁盘存在严重的性能瓶颈。当饱和度为100%时,磁盘无法接受新的I/O请求。 响应时间响应时间,是指I/O请求从发出到收到响应的间隔时间。 性能监测工具提供的指标 性能工具 性能指标 iostat 磁盘I/O使用率、IOPS、 吞吐量、响应时间、I/O平均大小以及等待队列长度 pidstat 进程I/O大小以及I/O延迟 sar 磁盘I/O使用率、IOPS 、吞吐量以及响应时间 dstat 磁盘I/O使用率、IOPS以及吞吐量 iotop 按I/O大小对进程排序 slabtop 目录项、索引节点以及文件系统的缓存 /proc/slabinfo 目录项、索引节点以及文件系统的缓存 /proc/meminfo 页缓存和可回收Slab缓存 /proc/diskstats 磁盘的IOPS、吞吐量以及延迟! /proc/pid/io 进程IOPS、IO大小以及IO延迟 vmstat 缓存和缓冲区用量汇总 blktrace 跟踪块设备I/O事件 biosnoop 跟踪进程的块设备I/O大小 biotop 跟踪进程块I/O并按I/O大小排序 strace 跟踪进程的I/O系统调用 perf 跟踪内核中的I/O事件 df 磁盘空间和索引节点使用量和剩余量 mount 文件系统的挂载路径以及挂载参数 du 目录占用的磁盘空间大小 tune2fs 显示和设置文件系统参数 hdparam 显示和设置磁盘参数 磁盘I/Oiostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况. szp@szp-pc:~$ iostat -d -x Linux 5.4.0-42-generic (szp-pc) 2020年08月01日 _x86_64_ (4 CPU) Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %util loop0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.80 0.00 0.00 2.35 0.00 1.40 0.00 loop1 0.01 0.00 0.05 0.00 0.00 0.00 0.00 0.00 0.49 0.00 0.00 4.46 0.00 0.41 0.00 loop2 0.00 0.00 0.04 0.00 0.00 0.00 0.00 0.00 0.65 0.00 0.00 10.64 0.00 1.14 0.00 loop3 0.05 0.00 0.08 0.00 0.00 0.00 0.00 0.00 2.17 0.00 0.00 1.65 0.00 0.23 0.00 loop4 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.49 0.00 0.00 8.00 0.00 1.66 0.00 loop5 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.40 0.00 0.00 2.47 0.00 1.02 0.00 loop6 0.01 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.22 0.00 0.00 2.44 0.00 0.49 0.00 loop7 0.01 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.28 0.00 0.00 2.34 0.00 0.59 以上指标的含义如下： 性能指标 含义 提示 r/s 每秒发送给磁盘的读请求数 合并后的请求数 w/s 每秒发送给磁盘的写请求数 合并后的请求数 rkB/s 每秒从磁盘读取的数据量 单位为kB wkB/s 每秒向磁盘写入的数据量 单位为kB rrqm/s 每秒合并的读请求数 %rrqm表示合并读请求的百分比 wrqm/s 每秒合并的写请求数 %wrqm表示合并写请求的百分比 r_await 读请求处理完成等待时间 包括队列中的等待时间和设备实际处理的时间，单位为毫秒 w_await 写请求处理完成等待时间 包括队列中的等待时间和设备实际处理的时间，单位为毫秒 aqu-sz 平均请求队列长度 旧版中为avgqu-sz rareq-sz 平均读请求大小 单位为kB wareq-sz 平均写请求大小 单位为kB svctm 处理I/O请求所需的平均时间(不包括等待时间) 单位为毫秒。注意这是推断的数据，并不保证完全准确 %util 磁盘处理I/O的时间百分比 即使用率，由于可能存在并行I/O，100%并不一定表明磁盘I/O饱和 %util，就是我们前面提到的磁盘 I/O 使用率； r/s+ w/s ，就是磁盘IOPS； rkB/s+wkB/s ，就是磁盘吞吐量； r_await+w_await ，就是磁盘响应时间。 进程I/Oiostat只提供磁盘整体的I/O性能数据，缺点在于 ,并不能知道具体是哪些进程在进行磁盘读写。要观察进程的I/O情况,你还可以使用pidstat和iotop这两个工具。 szp@szp-pc:~$ pidstat -d Linux 5.4.0-42-generic (szp-pc) 2020年08月01日 _x86_64_ (4 CPU) 16时26分59秒 UID PID kB_rd/s kB_wr/s kB_ccwr/s iodelay Command 16时26分59秒 0 1 -1.00 -1.00 -1.00 25 systemd 16时26分59秒 0 395 -1.00 -1.00 -1.00 3244 jbd2/sda1-8 16时26分59秒 0 446 -1.00 -1.00 -1.00 46 systemd-journal 从pidstat的输出你能看到,它可以实时查看每个进程的I/O情况,包括下面这些内容。 123456789用户ID (UID)和进程ID( PID)。每秒读取的数据大小( kB_rd/s),单位是 KB。每秒发出的写请求数据大小( kB_wr/s )，单位是KB。每秒取消的写请求数据大小( kB_ ccwr/s ),单位是 KB。块I/O延迟(iodelay) ,包括等待同步块I/O和换入块I/O结束的时间,单位是时钟周期。 kB_rd/s+kB_wr/s = 进程吞吐量 除了可以用pidstat实时查看,iotop可以按照I/O大小对进程排序,然后找到I/O较大的那些进程。 Total DISK READ : 0.00 B/s | Total DISK WRITE : 3.36 M/s Actual DISK READ: 0.00 B/s | Actual DISK WRITE: 4.70 M/s TID PRIO USER DISK READ DISK WRITE&gt; SWAPIN IO COMMAND 4116 be/4 root 0.00 B/s 1146.13 K/s 0.00 % 2.50 % snapd 4109 be/4 root 0.00 B/s 764.09 K/s 0.00 % 0.80 % snapd 4117 be/4 root 0.00 B/s 764.09 K/s 0.00 % 1.31 % snapd 4206 be/4 root 0.00 B/s 764.09 K/s 0.00 % 1.31 % snapd 1 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % init splash 2 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kthreadd] 上图为按照磁盘写速度进行排序的情况。 从这个输出,你可以看到,前两行分别表示,进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等。 剩下的部分,则是从各个角度来分别表示进程的1/O情况,包括线程ID、I/O优先级、每秒读磁盘的大小、每秒写磁盘的大小、换入和等待I/O的时钟百分比等。 IO延迟任何一个系统都有两个指标和性能紧密联系：响应时间和吞吐量。两个很关键的指标则是系统的IO延迟(响应时间)与IO吞吐量。 什么是IO延迟？1个完整的I/O传输，可能会经过以下路径：CPU -&gt;内存-&gt;硬盘细分一下如下：进程-&gt;虚拟文件系统-&gt;具体文件系统（页缓存）-&gt;通用块层（加入请求队列）-&gt;IO调度层-&gt;块设备驱动层-&gt;块设备层(操作磁盘)-&gt;磁盘 在上述I/O传输途径中消耗的时间就是IO延迟。我们习惯性的把IO的延迟分为以下几部分： 系统OS等软件配置产生的延迟：异步IO的情况下整个系统的延迟就会比同步IO下好很多。 硬件延迟：存储的延迟则是自身主控器+硬盘的延迟。存储主控上的缓存都比较大，加上存储厂家对命中率算法持续改进，以往单个硬盘因寻址、旋转产生的IO延迟时间都可以在一定比例上规避。 可以对io延迟做这样的划分：IO延迟时间=常量延迟+变量延迟 常量就是操作系统和数据库参数配置完毕后，那些硬件上的固定延迟加上一定存储命中率下软硬件共同作用产生的延迟时间，变量延迟就是io压力变大时，特别是海量随机小IO请求，导致的延迟变大。 主要监控指标和常用监控工具对于存储IO：unix、linux平台，Nmon、iostat是比较好的工具。 nmon用于事后分析，iostat可用于实时查看，也可以采用脚本记录下来事后分析。 IOPS 总IOPS：Nmon DISK_SUMM Sheet：IO/Sec 每个盘对应的读IOPS ：Nmon DISKRIO Sheet 每个盘对应的写IOPS ：Nmon DISKWIO Sheet 总IOPS：命令行iostat -Dl：tps 每个盘对应的读IOPS ：命令行iostat -Dl：rps 每个盘对应的写IOPS ：命令行iostat -Dl：wps 带宽 总带宽：Nmon DISK_SUMM Sheet：Disk Read KB/s，Disk Write KB/s 每个盘对应的读带宽：Nmon DISKREAD Sheet 每个盘对应的写带宽：Nmon DISKWRITE Sheet 总带宽：命令行iostat -Dl：bps 每个盘对应的读带宽：命令行iostat -Dl：bread 每个盘对应的写带宽：命令行iostat -Dl：bwrtn 响应时间 每个盘对应的读响应时间：命令行iostat -Dl：read - avg serv，max serv 每个盘对应的写响应时间：命令行iostat -Dl：write - avg serv，max serv 其他 磁盘繁忙程度、队列深度、每秒队列满的次数等等。 BCC中提供的IO延迟监测工具biotopbiotop是跟踪块设备I/O事件，并按照总的传输字节大小进行排序的工具，biotop总结了哪些事件执行了磁盘I / O，并打印出在一定时间间隔内，事件发送的进程id,平均等待时间，磁盘设备号等信息。 12345678910# ./biotopTracing... Output every 1 secs. Hit Ctrl-C to end08:04:11 loadavg: 1.48 0.87 0.45 1/287 14547PID COMM D MAJ MIN DISK I/O Kbytes AVGms14501 cksum R 202 1 xvda1 361 28832 3.396961 dd R 202 1 xvda1 1628 13024 0.5913855 dd R 202 1 xvda1 1627 13016 0.59 默认情况下，屏幕每1秒刷新一次，并显示前20个磁盘消费者，按总KB排序。 打印的第一行是标题，其中包含时间，然后包含/proc/loadavg的内容。其他bcc工具可用于获取更多详细的内容，例如biolatency 和 biosnoop。 biolatency该工具跟踪块设备IO(磁盘IO)的延迟分布情况： 123456789101112131415161718192021# ./biolatencyTracing block device I/O... Hit Ctrl-C to end.^C usecs : count distribution 0 -&gt; 1 : 0 | | 2 -&gt; 3 : 0 | | 4 -&gt; 7 : 0 | | 8 -&gt; 15 : 0 | | 16 -&gt; 31 : 0 | | 32 -&gt; 63 : 0 | | 64 -&gt; 127 : 1 | | 128 -&gt; 255 : 12 |******** | 256 -&gt; 511 : 15 |********** | 512 -&gt; 1023 : 43 |******************************* | 1024 -&gt; 2047 : 52 |**************************************| 2048 -&gt; 4095 : 47 |********************************** | 4096 -&gt; 8191 : 52 |**************************************| 8192 -&gt; 16383 : 36 |************************** | 16384 -&gt; 32767 : 15 |********** | 32768 -&gt; 65535 : 2 |* | 65536 -&gt; 131071 : 2 |* | 第一列表示延迟的时间范围，单位是微秒；第二列表示有多少事件属于该延迟时间段；第三列表示直方图。 ext4dist我们通常在块设备层（ block device layer）研究存储I/O延迟问题，如上面的biolatency和biotop工具，但是对文件系统进行检测可以提供更多相关的指标来了解应用程序如何受到影响。ext4dist工具针对ext4文件系统，跟踪读取（reads），写入（writes），打开（opens）和同步（fsync），并将其延迟汇总为直方图。 12345678910111213141516171819202122232425262728293031323334353637# ext4distTracing ext4 operation latency... Hit Ctrl-C to end.^Coperation = 'read' usecs : count distribution 0 -&gt; 1 : 1210 |****************************************| 2 -&gt; 3 : 126 |**** | 4 -&gt; 7 : 376 |************ | 8 -&gt; 15 : 86 |** | 16 -&gt; 31 : 9 | | 32 -&gt; 63 : 47 |* | 64 -&gt; 127 : 6 | | 128 -&gt; 255 : 24 | | 256 -&gt; 511 : 137 |**** | 512 -&gt; 1023 : 66 |** | 1024 -&gt; 2047 : 13 | | 2048 -&gt; 4095 : 7 | | 4096 -&gt; 8191 : 13 | | 8192 -&gt; 16383 : 3 | |operation = 'write' usecs : count distribution 0 -&gt; 1 : 0 | | 2 -&gt; 3 : 0 | | 4 -&gt; 7 : 0 | | 8 -&gt; 15 : 75 |****************************************| 16 -&gt; 31 : 5 |** |operation = 'open' usecs : count distribution 0 -&gt; 1 : 1278 |****************************************| 2 -&gt; 3 : 40 |* | 4 -&gt; 7 : 4 | | 8 -&gt; 15 : 1 | | 16 -&gt; 31 : 1 | 此输出显示读取延迟的双峰分布，其中分别为延迟小于7微秒的较快事件和256至1023微秒之间的较慢事件。 计数列显示有多少事件属于该延迟范围。 较快的事件可能是内存中文件系统高速缓存命中的原因，较慢的事件是从存储设备（磁盘）中读取的。 ext4slowerext4slower显示ext4的读取，写入，打开和同步操作，其速度低于阈值的所有事件。该工具与上一个工具不同之处在于，该工具提供了一个延迟时间阈值参数，可以监测到所有延迟低于某个阈值的事件，并打印输出。当然这仅能跟踪常见文件系统操作，其他文件系统操作（例如，inode操作，getattr()）不会跟踪。 1234567891011121314151617181920212223# ./ext4slowerTracing ext4 operations slower than 10 msTIME COMM PID T BYTES OFF_KB LAT(ms) FILENAME06:35:01 cron 16464 R 1249 0 16.05 common-auth06:35:01 cron 16463 R 1249 0 16.04 common-auth06:35:01 cron 16465 R 1249 0 16.03 common-auth06:35:01 cron 16465 R 4096 0 10.62 login.defs06:35:01 cron 16464 R 4096 0 10.61 login.defs06:35:01 cron 16463 R 4096 0 10.63 login.defs06:35:01 cron 16465 R 2972 0 18.52 pam_env.conf06:35:01 cron 16464 R 2972 0 18.51 pam_env.conf06:35:01 cron 16463 R 2972 0 18.49 pam_env.conf06:35:01 dumpsystemstat 16473 R 128 0 12.58 date06:35:01 debian-sa1 16474 R 283 0 12.66 sysstat06:35:01 debian-sa1 16474 R 128 0 10.39 sa106:35:01 dumpsystemstat 16491 R 128 0 13.22 ifconfig06:35:01 DumpThreads 16534 R 128 0 12.78 cut06:35:01 cron 16545 R 128 0 14.76 sendmail06:35:01 sendmail 16545 R 274 0 10.88 dynamicmaps.cf06:35:02 postdrop 16546 R 118 0 32.94 Universal06:35:02 pickup 9574 R 118 0 21.02 localtime[...] 以上是所有延迟时间大于10毫秒的事件。 此“延迟时间”是从虚拟文件系统（VFS）向文件系统的接口发起操作时算起的，直到完成。 这涵盖了所有内容：块设备I/O（磁盘I/O），文件系统CPU周期，文件系统锁，请求队列等待时间等。这是对延迟时间的更好衡量。因为应用程序从文件系统读取，而不是通过块设备层接口读取。]]></content>
  </entry>
  <entry>
    <title><![CDATA[系统调用机制]]></title>
    <url>%2Funcategorized%2F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[系统调用机制现在所有的通用OS都提供了许多系统调用，但它们所提供的系统调用会有一定的差异。对于一般通用的OS而言，可将系统调用分为如下三大类。 进程控制类系统调用主要用于对进程控制的系统调用有： 创建和终止进程的系统调用。 获得和设置进程属性的系统调用。 等待某事件出现的系统调用。 文件操纵类系统调用对文件进行操纵的主要系统调用如下： 创建和删除文件。 打开和关闭文件的系统调用。 读和写文件的系统调用。 进程通信类系统调用除上诉三类系统调用外，常用的系统调用还包括设备管理类系统调用和信息维护类系统调用，前者主要用于实现申请设备、释放设备、设备I/O和重定向、获得和设置设备属性等功能，后者主要用来获得包括有关系统和文件的时间、日期信息、操作系统版本、当前用户以及有关空闲内存和磁盘空间大小等多方面的信息。 Linux三种接口Linux提供了用户接口（shell），库函数接口（C语言程序调用库），系统调用接口三种接口。在系统调用接口这一层中，许多操作系统都提供了上面所介绍的各种类型的系统调用，实现的功能也相类似，但在实现的细节和形式方面却相差很大，这种差异给实现应用程序与操作系统平台的无关性带来了很大的困难。为解决这一问题，国际标准化组织ISO给出的有关系统调用的国际标准POSIX1003.1 (Portable OperatingSystem IX)，也称为“基于UNIX的可移植操作系统接口”。 POSIX定义了标准应用程序接口(API)，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行。只有符合这一标准的应用程序，才有可能完全兼容多种操作系统,即在多种操作系统下都能够运行。 POSIX标准定义了一组过程，这组过程是构造系统调用所必须的，这组过程也就是下面要介绍的系统调用处理过程。通过调用这些过程所提供的服务，确定了一系列系统调用的功能。 需要明确的是，POSIX标准所定义的一组过程虽然指定了系统调用的功能，但并没有明确规定系统调用是以什么形式实现的，是库函数还是其它形式。 如早期操作系统的系统调用使用汇编语言编写，这时的系统调用可看成是扩展的机器指令，因而，能在汇编语言编程中直接使用。而在一些高级语言或C语言中，尤其是最新推出的一些操作系统，如UNIX新版本、Linux、Windows 和OS/2等，其系统调用干脆用C语言编写，并以库函数形式提供，所以在用C语言编写的应用程序中，可直接通过使用对应的库函数来使用系统调用，库函数的目的是隐藏访管指令的细节，使系统调用更像过程调用。但一般地说，库函数属于用户程序而非系统调用程序。如下图UNIX/Linux的系统程序、库函数、系统调用的层次关系。 系统调用与API有什么区别？区别：API是函数的定义，规定了这个函数的功能，跟内核无直接关系，最流行的API标准就是posix标准。 系统调用是通过中断向内核发请求，实现内核提供的某些服务。 C语言库函数则是基于Posix标准的具体实现。 联系：一个API可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个API需要跟内核打交道就需要系统调用，否则不需要。程序员调用的是API（如C库函数），然后通过与系统调用共同完成函数的功能。因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。并不是所有的API函数都一一对应一个系统调用，有时一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）。 strace命令跟踪进程中的系统调用strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。 使用-c参数可以打印出每一个系统调用执行的时间，被调用的次数，出错的次数，系统调用的名称。其他参数如下所示。 命令详细参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-c 统计每一系统调用的所执行的时间,次数和出错的次数等.-d 输出strace关于标准错误的调试信息.-f 跟踪由fork调用所产生的子进程.-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.-h 输出简要的帮助信息.-i 输出系统调用的入口指针.-q 禁止输出关于脱离的消息.-r 打印出相对时间关于,,每一个系统调用.-t 在输出中的每一行前加上时间信息.-tt 在输出中的每一行前加上时间信息,微秒级.-ttt 微秒级输出,以秒了表示时间.-T 显示每一调用所耗的时间.-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.-V 输出strace的版本信息.-x 以十六进制形式输出非标准字符串-xx 所有字符串以十六进制形式输出.-a column设置返回值的输出位置.默认 为40.-e expr指定一个表达式,用来控制如何跟踪.格式如下:[qualifier=][!]value1[,value2]...qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.注意有些shell使用!来执行历史记录里的命令,所以要使用\\.-e trace=set只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.-e trace=file只跟踪有关文件操作的系统调用.-e trace=process只跟踪有关进程控制的系统调用.-e trace=network跟踪与网络有关的所有系统调用.-e strace=signal跟踪所有与系统信号有关的 系统调用-e trace=ipc跟踪所有与进程通讯有关的系统调用-e abbrev=set设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.-e raw=set将指 定的系统调用的参数以十六进制显示.-e signal=set指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.-e read=set输出从指定文件中读出 的数据.例如:-e read=3,5-e write=set输出写入到指定文件中的数据.-o filename将strace的输出写入文件filename-p pid跟踪指定的进程pid.-s strsize指定输出的字符串的最大长度.默认为32.文件名一直全部输出.-u username以username 的UID和GID执行被跟踪的命令 从用户态函数到系统调用 比如在程序中调用fwrite函数，而fwrite函数在 glibc库中调用系统调用write()，然后从用户态陷入内核态，查找系统调用表，对应的系统调用服务例程为sys_ write。 系统调用中涉及的基本概念系统态和用户态在计算机系统中，通常运行着两类程序：系统程序和应用程序。为了防止应用程序对OS的破坏，应用程序和OS的内核是运行在不同的状态，即OS的内核是运行在系统态，而应用程序是运行在用户态。 在计算机系统中设置了两种状态：系统态(或称为核心态)和用户态。在实际运行过程中，处理机会在系统态和用户态间切换。相应地，现代多数OS将CPU的指令集分为特权指令和非特权指令两类。 特权指令。特权指令是指在系统态运行的指令，它对内存空间的访问范围基本不受限制，不仅能访问用户空间，也能访问系统空间。如启动外部设备、设置系统时钟时间、关中断、转换执行状态等。特权指令只允许OS使用，不允许应用程序使用，以避免引起系统混乱。 非特权指令。非特权指令是在用户态运行的指令。应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务，不能对系统中的硬件和软件直接进行访问，对内存的访问范围也局限于用户空间。这样，可以防止应用程序的运行异常对系统造成破坏。 这种限制是由硬件实现的，如果在应用程序中使用了特权指令，就会发出权限出错信号，操作系统捕获到这个信号后，将转入相应的错误处理程序，将停止该应用程序的与逆行，重新调度。 中断和陷入中断是指CPU对系统发生某事件时的这样一种响应: CPU暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序;执行完后，再返回到原程序的断点处继续执行。下图表示中断时CPU的活动轨迹。还可进一步把中断分为外中断和内中断。所谓外中断，是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等;而内中断则是指由于CPU内部事件所引起的中断，如程序出错(非法指令、地址越界)、电源故障等。内中断(trap)也被译为“捕获”或“陷入”。 通常，陷入是由于执行了现行指令所引起的;而中断则是由于系统中某事件引起的，该事件与现行指令无关。由于系统调用引起的中断属于内中断，因此把由于系统调用引起中断的指令称为陷入指令。 系统调用号和参数在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行哪个系统调用。进程不会提及系统调用的名称。 系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。 因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在系统调用命令(陷入指令)中把相应的系统调用号传递给中断和陷入机制的方法有很多种，在有的系统中，直接把系统调用号放在系统调用命令(陷入指令)中;如IBM 370和早期的UNIX系统，是把系统调用命令的低8位用于存放系统调用号;在另一些系统中,则将系统调用号装入某指定寄存器或内存单元中，如MS-DOS是将系统调用号放在AH寄存器中，Linux则是利用EAX寄存器来存放应用程序传递的系统调用号。 在陷人内核之前，用户空间就把相应系统调用所对应的号放入eax中了。这样系统调用处理程序一旦运行，就可以从eax中得到数据。其他体系结构上的实现也都类似。 内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在sys_call_table中。 sys_call_table是一张由指向实现各种系统调用的内核函数的函数指针组成的表,一般在entry.s中定义。这个表中为每一个有效的系统调用指定了惟一的系统调用号。 除了系统调用号以外，大部分系统调用都还需要一些外部的参数输入。在执行系统调用时，如何设置系统调用所需的参数，即如何将这些参数传递给陷入处理机构和系统内部的子程序(过程)，常用的实现方式有以下几种： 陷入指令自带方式。陷入指令除了携带一个系统调用号外，还要自带几个参数进入系统内部，由于一条陷入指令的长度是有限的，因此自带的只能是少量的、有限的参数。 直接将参数送入相应的寄存器中。MS-DOS便是采用的这种方式，即用MOV指令将各个参数送入相应的寄存器中。系统程序和应用程序都可以对这些寄存器进行访问。这种方式的主要问题是这种寄存器数量有限，限制了所设置参数的数目。 参数表方式。将系统调用所需的参数放入一张参数表中，再将指向该参数表的指针放在某个指定的寄存器中。当前大多数的OS中，如UNIX系统和Linux系统，便是采用了这种方式。在x86系统上，ebx, ecx, edx, esi和edi按照顺序存放前五个参数。 如何处理系统调用在设置了系统调用号和参数后，便可执行一条系统调用命令。不同的系统可采用不同的执行方式。在UNIX系统中，是执行CHMK命令；而在MS-DOS中则是执行INT21软中断。系统调用的处理过程可分成以下三步：首先，将处理机状态由用户态转为系统态；之后，由硬件和内核程序进行系统调用的一般性处理，即首先保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、系统调用号、用户栈指针以及通用寄存器内容等压入堆栈；然后，将用户定义的参数传送到指定的地址并保存起来。 其次，分析系统调用类型，转入相应的系统调用处理子程序。为使不同的系统调用能方便地转向相应的系统调用子程序，在系统中配置了一张系统调用入门表。表中的每个每个表目都对应一个系统调用，其中包含该系统调用自带参数的数目、系统调用处理子程序的入口地址等。因此，核心可利用系统调用号去查找该表，即可找到相应处理子程序的入口地址而转去执行它。 最后，在系统调用处理子程序执行完后，应恢复被中断的或设置新进程的CPU现场，然后返回被中断进程或新进程，继续向下执行。 下面我们从用户态跟踪一个系统调用到内核态。 操作系统使用系统调用表将系统调用编号翻译为特定的系统调用。系统调用表包含有实现每个系统调用的函数的地址。例如，fork() 系统调用函数名为sys_fork。fork()系统调用编号是2，所以sys_fork() 位于系统调用表的第四个条目中（因为系统调用起始编号为0）。从地址 sys_call_table + (2 * word_size) 读取数据，得到sys_fork()的地址。 找到正确的系统调用地址后，它将控制权转交给那个系统调用。 读取函数结束后，从sys_fork()返回，它将控制权切换给 ret_from_sys。它会去检查那些在切换回用户空间之前需要完成的任务。如果没有需要做的事情，那么就恢复用户进程的状态，并将控制权交还给用户程序。 系统调用实例简介系统调用安全，直接关系操作系统内核的安全，试想一个程序可以肆意的调用内核程序，将会非常危险，因此设计一个日志收集系统记录下每次系统调用的时间，调用的程序，将有助于系统管理员排查故障。 举例来说，与文件I/O相关的系统调用必须检查文件描述符是否有效。与进程相关的函数必须检查提供的PID是否有效。必须检查每个参数，保证它们不但合法有效，而且正确。最重要的一种检查就是检查用户提供的指针是否有效。试想，如果一个进程可以给内核传递指针而又无须被检查，那么它就可以给出一个它根本就没有访问权限的指针，哄骗内核去为它拷贝本不允许它访问的数据，如原本属于其他进程的数据。具体的实现过程将在下一节详细介绍。]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件共享与保护]]></title>
    <url>%2Funcategorized%2F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[文件共享在现代计算机系统中，必须提供文件共享手段，即指系统应允许多个用户(进程)共享同一份文件。这样，在系统中只需保留该共享文件的一份副本。如果系统不能提供文件共享功能，就意味着凡是需要该文件的用户，都须各自备有此文件的副本，显然这会造成对存储空间的极大浪费。 随着计算机技术的发展，文件共享的范围也在不断扩大，从单机系统中的共享，扩展为多机系统的共享，进而又扩展为计算机网络范围的共享，甚至实现全世界的文件共享。 早在20世纪的60和70年代，已经出现了不少实现文件共享的方法，如绕弯路法、连访法，以及利用基本文件实现文件共享的方法;而现代的一些文件共享方法，也是在早期这些方法的基础上发展起来的。下面我们仅介绍当前常用的两种文件共享方法，它们是在树形结构目录的基础上经适当修改形成的。 基于有向无循环图实现文件共享（硬链接）有向无循环图DAG(Directed Acyclic Graph)在严格的树形结构目录中，每个文件只允许有一个父目录，父目录可以有效地拥有该文件，其它用户要想访问它，必须经过其属主目录来访问该文件。这就是说，对文件的共享是不对称的，或者说，树形结构目录是不适合文件共享的。如果允许一个文件可以有多个父目录，即有多个属于不同用户的多个目录，同时指向同一个文件，这样虽会破坏树的特性，但这些用户可用对称的方式实现文件共享，而不必再通过其属主目录来访问。 上图展示出了一个有向无循环图，它允许每一个文件都可以有多个父目录。如图中的文件F8有三个父目录，它们分别是D5、D6和D3,其中D5和D3还使用了相同的名字p,目录D6有两个父目录D2和D1。 由上所述得知，当有多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到多个用户的父目录中，才能方便地找到该文件。现在的问题是，如何建立父目录D5与共享文件F8之间的链接呢? 如果在文件目录中所包含的是文件的物理地址,即文件所在盘块的盘块号，则在链接时，必须将文件的物理地址拷贝到D5目录中去。但如果以后D5或D6还要继续向该文件中添加新内容，也必然要相应地再增加新的盘块，这些是由附加操作Append 来完成的。而这些新增加的盘块也只会出现在执行了操作的目录中。 可见, 这种变化对其他用户而言，是不可见的，因而新增加的这部分内容已不能被共享。 利用索引结点为了解决这个问题，可以引用索引结点，即诸如文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针，如下图所示。 图中的用户Wang和Lee的文件目录中，都设置有指向共享文件的索引结点指针。此时，由任何用户对共享文件所进行的Append操作或修改，都将引起其相应结点内容的改变(例如，增加了新的盘块号和文件长度等)，这些改变是其他用户可见的，从而也就能提供给其他用户来共享。 在索引结点中还应有一个链接计数count,用于表示链接到本索引结点(亦即文件)上的用户目录项的数目。当count=3 时，表示有三个用户目录项连接到本文件上，或者说是有三个用户共享此文件。 当用户C创建一个新文件时，他便是该文件的所有者，此时将count置1。当有用户B要共享此文件时，在用户B的目录中增加一目录项,并设置一指针指向该文件的索引结点，此时，文件主仍然是C,count=2。如果用户C不再需要此文件，是否能将此文件删除呢?回答是否定的。因为，若删除了该文件，也必然删除了该文件的索引结点，这样便会使B的指针悬空，而B则可能正在此文件上执行写操作，此时将因此半途而废。但如果C不删除此文件而等待B继续使用，这样，由于文件主是C,如果系统要记账收费，则C必须为B使用此共享文件而付账，直至B不再需要。下图展示出了B链接到文件前后的情况。 ln命令可以创建硬链接： ln 源文件 目标文件 这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。 基于符号链的共享方式（软链接）符号链接基本思想利用符号链接实现文件共享的基本思想，是允许一个文件或子目录有多个父目录，但其中仅有一个作为主(属主)父目录，其它的几个父目录都是通过符号链接方式与之相链接的(简称链接父目录)。 当访问“c”时，操作系统判断文件“c”属于Link 类型文件，于是会根据其中记录的路径层层查找目录，最终找到目录表1中的“a”表项，于是就找到了文件1的索引结点。 符号链接实现共享的优点在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针；而共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引结点的指针。这样，也就不会发生在文件主删除一共享文件后留下一悬空指针的情况。当文件的拥有者把一个共享文件删除后，如果其他用户又试图通过符号链去访问一个已被删除的共享文件，则会因系统找不到该文件而使访问失败，于是再将符号链删除，此时不会产生任何影响。 值得一提的是，在计算机网络中，Web浏览器在进行浏览时所使用的文件是HTML类型的文件。在HTML文件中有着许多链接符，通过这些链接符能够链接(通过计算机网络)世界上任何地方的机器中的文件。在利用符号链实现共享时，同样可以通过网络链接到分布在世界各地的计算机系统中的文件。 &lt; a href=”url”&gt;链接文本&lt;/ a&gt; ln -s命令可以创建软链接： ln -s 源文文件或目录 目标文件或目录 小结 文件系统的安全性安全性两个方面确保未经授权的用户不能存取某些文件。涉及到技术、管理、法律、道德和政治等问题。 安全性的两个重要方面： 数据丢失。 灾难 硬件或软件故障 人的失误。可通过磁盘容错技术和备份(存放在另一处)来解决。 入侵者。（积极的或消极的) 非技术人员的偶然窥视 入侵者的窥视 明确的偷窃企图 商业或军事间谍活动 设计安全时要考虑是那一类入侵者. 文件的保护机制(1) 文件保护 用于提供安全性的特定的操作系统机制。 (有权限的用户, 应让其进行相应操作, 否则, 应禁止) 实现：用户验证、存取控制 (2) 用户验证用户登录, 检验其身份 口令 物理鉴定 磁卡，指纹，签名分析，手指长度分析 (3) 存取控制 审查用户的权限 审查本次操作的合法性 为了确保文件系统的安全性，可针对上述原因而采取以下措施: (1)通过存取控制机制来防止由人为因素所造成的文件不安全性。 (2)通过磁盘容错技术来防止由磁盘部分的故障所造成的文件不安全性。 (3)通过“后备系统”来防止由自然因素所造成的不安全性。 接下来我们主要看一下第二方面磁盘容错技术。 第一级 磁盘容错技术SFT-1第一级容错技术(SFT- I )是最基本的一种磁盘容错技术,主要用于防止因磁盘表面缺陷所造成的数据丢失。它包含双份目录、双份文件分配表及写后读校验等措施。 双份目录和双份文件分配表在磁盘上存放的文件目录和文件分配表FAT，是文件管理所用的重要数据结构。 为了防止这些表格被破坏，可在不同的磁盘上或在磁盘的不同区域中，分别建立(双份)目录表和FAT。 其中一份为主目录及主FAT;另一份为备份目录及备份FAT。一但由于磁盘表面缺陷而造成主文件目录或主FAT的损坏时，系统便自动启用备份文件目录及备份FAT，从而可以保证磁盘上的数据仍是可访问的。 热修复重定向和写后读校验由于磁盘价格昂贵，当磁盘表面有少量缺陷时，则可采取某种补救措施后继续使用磁盘。一般主要采取以下两个补救措施: 热修复重定向:系统将磁盘容量的一部分(例如2%~ 3%)作为热修复重定向区，用于存放当发现磁盘有缺陷时的待写数据，并对写入该区的所有数据进行登记，以便于以后对数据进行访问。 写后读校验方式。为了保证所有写入磁盘的数据都能写入到完好的盘块中，应该在每次从内存缓冲区向磁盘中写入一个数据块后，又立即从磁盘上读出该数据块，并送至另缓冲区中，再将该缓冲区内容与内存缓冲区中在写后仍保留的数据进行比较。若两者一致，便认为此次写入成功, 可继续写下一一个盘块;否则，再重写。若重写后两者仍不一致,则认为该盘块有缺陷，此时，便将应写入该盘块的数据，写入到热修复重定向区中。 第二级磁盘容错技术SFT-2磁盘镜像-两个磁盘驱动器互为备份为了避免磁盘驱动器发生故障而丢失数据，便增设了磁盘镜像功能。为实现该功能，须在同一磁盘控制器下再增设一个完全相同的磁盘驱动器，如图所示。当采用磁盘镜像方式时，在每次向主磁盘写入数据后，都需要将数据再写到备份磁盘上，使两个磁盘上具有完全相同的位像图。 把备份磁盘看作是主磁盘的一面镜子，当主磁盘驱动器发生故障时，由于有备份磁盘的存在，在进行切换后，使主机仍能正常工作。磁盘镜像虽然实现了容错功能，但未能使服务器的磁盘I/O速度得到提高，却使磁盘的利用率降至仅为50%。 磁盘双工(Disk Duplexing)如果控制这两台磁盘驱动器的磁盘控制器发生故障，或主机到磁盘控制器之间的通道发生了故障，磁盘镜像功能便起不到数据保护的作用。 因此，在第二级容错技术中，又增加了磁盘双工功能，即将两台磁盘驱动器分别接到两个磁盘控制器上，同样使这两台磁盘机镜像成对，如图所示。在磁盘双工时，文件服务器同时将数据写到两个处于不同控制器下的磁盘上，使两者有完全相同的位像图。如果某个通道或控制器发生故障时，另一个通道上的磁盘仍能正常工作，不会造成数据的丢失。在磁盘双工时，由于每一个磁盘都有自己的独立通道，故可同时(并行)地将数据写入磁盘,或读出数据。 文件系统的数据一致性控制同一数据存放在不同的文件中, 对它修改时应对不同的文件都统一修改, 才能保证数据的一致性。修改时数据的流向是, 磁盘块、内存、写回磁盘块。若在写回之前, 系统崩溃, 则文件系统数据出现不一致。 系统应配置保证数据一致性的软件和相应的硬件，硬件采取冗余技术配置一个高度可靠的存储系统, 称为稳定存储器; 目前广泛采用磁盘双工方式来实现稳定存储器。设计保证数据一致性的实用程序, 当系统再次启动时, 运行该程序, 检查磁盘块和目录系统。 事务定义事务是用于访问和修改数据的一个程序单位, 由一系列相关的读写操作组成; 被访问的数据可以分散在不同位置, 只有一系列读写操作全部完成才能以托付操作(Commit Operation)终止操作; 而只要有一个操作失败就执行夭折操作(Abort Operation)。 为了保证数据的一致性, 对于夭折事务所操作过的数据必须恢复原来的状态, 使该事务退回(rolled back),保证一个事务对一批数据修改操作,要么全部完成要么 一个也不修改, 这种特性称事务的原子性。 事务记录为了实现上述的原子修改，通常须借助于称为事务记录的数据结构来实现。这些数据结构被放在稳定存储器中，用来记录在事务运行时数据项修改的全部信息，故又称为运行记录(Log)。该记录中包括有下列字段: 事务名:用于标识该事务的惟一名字; 数据项名:指被修改数据项的惟一名字; 旧值:修改前数据项的值; 新值:修改后数据项将具有的值。恢复算法由于一组被事务Ti修改的数据以及它们被修改前和修改后的值都能在事务记录表中找到，因此，利用事务记录表， 系统能处理任何故障而不致使故障造成非易失性存储器中信 系统能处理任何故障而不致使故障造成非易失性存储器中信息的丢失。恢复算法可利用以下两个过程: undo〈Ti〉。 该过程把所有被事务Ti修改过的数据 恢复为修改前的值。 恢复为修改前的值。 redo〈Ti〉。 该过程把所有被事务Ti修改过的数据设置为新值。 检查点检查点的作用使对为了对事务记录的清理工作经常化, 设置检查点记录; 每隔一定的时间做一次清理: 将内存中的当前事务记录表的所有记录, 和所有已修改的数据, 输出到稳定存储器中; 再将检查点记录输出到稳定存储器中; 每当出现一个检查点记录便执行恢复操作。 新的恢复算法发生故障后,恢复算法只需对最后一个检查点之后的事务记录进行处理。 即从最后一个检查点之后的第一个事务记录开始,对所有的事务Tk , 在Log表中出现(Tk托付)记录则执行redo(Tk ), 未出现(Tk托付)记录则执行undo(Tk )。 并发控制由于事务具有的原子性, 使得一个事务执行完后才允许另一事务执行, 即事务对数据项的修改是互斥的,事务的这种特性称为顺序性,将实现顺序性的技术称为并发控制。可以用互斥信号量来保证事务处理的顺序性,但用的最广的是“锁”。 利用互斥锁实现顺序性设置一种用于实现互斥的锁, 简称互斥锁,为每一个共享对象设一把互斥锁, 如果事务 Ti 需要对一批对象进行访问,则为了保证事务操作的原子性, 应先获得这批对象的互斥锁, 将他们全部锁住, 如果成功便可以对这批对象执行读写操作,然后全部开锁, 若某对象已被其它事务锁住, 则Ti 要将已锁住的对象全部开锁。 重复数据的一致性问题重复文件的一致性以UNIX类型的文件系统为例,通常文件一个文件的目录项由一个文件名和一个索引结点号组成; 当有重复文件时, 一个文件的目录项由一个文件名和若干个索引结点号组成。保证重复文件的一致性用两种方法： (1) 当一个文件被修改后,可查目录, 从各i结点找到各拷贝的物理位置, 对这些拷贝做同样修改。 (2) 为新修改的文件建立几个新拷贝取代原来的拷贝。 盘块号一致性的检查两张表，每块对应一个表中的计数器，初值为0，正常情况下空闲块计数表与数据块计数表对应项的值应该是互补关系。 表一：记录了每块在空闲块表中出现的次数 表二：记录了每块在文件中出现的次数 链结数一致性的检查在UNIX的文件目录中,索引结点中有一个链接计数 count, 它用来表示共享文件计数, 它应该和目录中指向该索引结点的数目一致。否则出错。 为检查不一致差错, 同样配置一张计数器表, 为每个文件建立一个表项, 检查时从根结点开始, 查找并计数,检查完后, 将计数器表的每个计数值与count 对比, 一致则正确, 否则发生链接数不一致差错。 count值大于计数表的计数值则该文件永远不会被删除; count值小于计数表的计数值则该文件会被误删除; 这两种情况解决方法是将count值修改正确。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux字符设备驱动程序]]></title>
    <url>%2Funcategorized%2FLinux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[5.4 Linux设备驱动分类Linux系统将设备分为三个类：字符设备、块设备、网络设备，在这三大类中，字符设备相对比较简单，应用程序通过字符设备文件来访问字符设备，本讲主要介绍字符设备，如果对块设备和网络设备感兴趣的话，可以参看相关资料，并对其进行深入了解。 什么是字符设备？字符设备是指只能一个字节一个字节进行读写操作的设备，不能随机读取设备中的某一数据、读取数据要按照先后顺序。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED等。 一般每个字符设备或者块设备都会在/dev目录下对应一个设备文件，并且每个设备文件都必须有主/次设备号，主设备号相同的设备是同类设备，使用同一个驱动程序。 Linux用户层程序通过设备文件来使用驱动程序操作字符设备或块设备。 可以通过 cat /proc/devices 命令查看当前已经加载的设备驱动程序的主设备号。 通过在/dev目录下执行命令 ls -l 可以看到所有设备文件的主设备号和次设备号： 对常见设备文件作如下说明： 点击查看详细内容 /dev/hd[a-t]：IDE设备 /dev/sd[a-z]：SCSI设备 /dev/fd[0-7]：标准软驱 /dev/md[0-31]：软raid设备 /dev/loop[0-7]：本地回环设备 /dev/mem：内存 /dev/null：无限数据接收设备,相当于黑洞 /dev/zero：无限零资源 /dev/tty[0-63]：虚拟终端 /dev/ttyS[0-3]：串口 /dev/lp[0-3]：并口 /dev/console：控制台 /dev/fb[0-31]：framebuffer /dev/cdrom =&gt; /dev/hdc /dev/modem =&gt; /dev/ttyS[0-9] /dev/pilot =&gt; /dev/ttyS[0-9] 如何建立设备文件？建立设备文件有两种方式，一是通过系统调用mknod()，编程中调用该函数可以建立一个新的设备文件名，另外一种就是通过mknod命令，命令的第一个参数为设备文件名，第二个参数为设备类型，比如c表示字符设备，第三、四个参数为设备文件的主设备号和次设备号，比如231和0。主设备号和次设备号合起来唯一的确定一个设备，同一个设备不同类型的主设备号是一样的，次设备号不同，比如一个硬盘的多个分区就有不同的次设备号，通过主设备号就可以把设备文件与驱动程序关联起来。 mknod filename type major minor filename：要创建的设备文件名； type：设备类型，c代表一个字符设备，b代表一个块设备； major：主设备号； minor：次设备号； 如何描述字符设备？Linux内核中抽象出struct cdev结构体来表示一个字符设备，cdev 定义于 &lt;linux/cdev.h&gt; 中其中，其中最关键的是file_operations结构，它是实现字符设备的操作集。 12345678struct cdev &#123; struct kobject kobj; // 内嵌内核对象 struct module *owner; //该字符设备所在的内核模块 const struct file_operations *ops; //文件操作结构体 struct list_head list; //已注册字符设备链表 dev_t dev; //由主、次设备号构成的设备号 unsigned int count;//同一主设备号的次设备号的个数&#125;; Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个系统调用。 123456789101112131415161718struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char *, size_t, loff_t *); ssize_t (*write) (struct file *, const char *, size_t, loff_t *); int (*readdir) (struct file *, void *, filldir_t); unsigned int (*poll) (struct file *, struct poll_table_struct *); int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, struct dentry *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*readv) (struct file *, const struct iovec *, unsigned long,loff_t *); ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *); &#125;; 用户进程利用在对设备文件进行诸如read，write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。 字符设备与文件系统的接口 如图，在Linux内核中，最左边， 使用cdev结构体来描述字符设备;通过其成员dev_t来定义设备号（分为主、次设备号）以确定字符设备的唯一性;通过其成员file_operations来定义字符设备驱动提供给虚拟文件系统VFS的接口函数，如常见的open()、read()、write()等,这些函数真正的操作硬件设备。 在上一个图的基础上我们看这个图，字符设备驱动程序是以内核模块的形式加载到内核中的，首先模块加载函数按静态或者动态方式获取设备号；然后字符设备初始化函数建立cdev与 file_operations之间的连接， 通过注册函数向系统添加一个cdev以完成注册; 模块卸载时与加载对应，要注销cdev，并释放设备号。 在用户程序中，可以通过系统调用open(), read(), write()等调用驱动程序在内核中所实现的这些函数。这样用户态到内核驱动之间的通路就打通了。 编写简单的字符设备驱动程序 如图，编写字符设备驱动分为三大步骤： 驱动的初始化，其中又分为四个步骤，调用相关的函数达到。 实现设备的操作，具体的操作取决于你自己所要实现的功能，这里只列出了基本的操作 驱动的注销，注销就是释放资源。 其中调用的接口函数功能如下： 第1个函数是分配函数，动态申请cdev的内存，给该结构分配内存空间。 第2个函数是初始化函数，初始化cdev的成员，并建立cdev和file_operations之间关联. 第3个函数注册cdev设备对象，也就是把字符设备添加到字符设备表中，就像大家入学时进行注册一样。 第4个函数是注销驱动程序调用，将cdev对象从系统中删除。 第5个函数释放cdev数据结构所占的内存。 设备号的申请和释放一个字符设备或块设备都有一个主设备号和一个次设备号。主设备号用来标识与设备文件相连的驱动程序，用来反映设备类型。次设备号被驱动程序用来辨别操作的是哪个设备，用来区分同类型的设备。注册时申请设备号，注销时释放设备号，就像大家入学是有一个学号，毕业离开时就释放掉这个学号。 用户空间与内核空间数据的传送当我们在用户程序中调用read（）函数时，陷入内核空间，实际上要通过内核的copy_to_user()函数把内核空间缓冲区中的数据拷贝到用户空间的缓冲区，反之，当我们调用write（)函数时，内核通过调用copy_from_user()函数把用户空间的数据拷贝到内核缓冲区。 小结如何具体编写一个字符驱动程序，主要有三个步骤，一是驱动的初始化，二是实现对设备的具体操作，三是注销驱动程序， 在动手实践一节，将给出一个字符设备驱动程序的编写过程以及运行机制。]]></content>
  </entry>
  <entry>
    <title><![CDATA[I/O设备驱动程序]]></title>
    <url>%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FIO%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[5.3 I/O设备驱动程序 什么是设备驱动程序？设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序，其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令，文件系统把这些请求转换为具体要求后，发送给设备控制器，启动设备去执行；反之，它也将由设备控制器发来的信号传送给上层软件。 思考一下为何不同的设备需要不同的设备驱动程序？ 由于驱动程序与硬件密切相关，故通常应为每一类设备配置一种驱动程序。例如，打印机和显示器需要不同的驱动程序。 不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。 设备驱动程序的功能实现I/O进程与设备控制器之间的通信,设备驱动程序应具有以下功能 接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。 例如，将磁盘块号转换为磁盘的盘面、磁道号及扇区号。 检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。 发出I/O命令，如果设备空闲，立即启动I/O设备，完成指定I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。 设备驱动程序的特点设备驱动程序属于低级的系统例程，它与一般的应用程序及系统程序之间有下述明显差异。 驱动程序主要是指在请求I/O的进程与设备控制器之间的一个通信和转换程序。 它将进程的I/O请求经过转换后，传送给控制器；又把控制器中所记录的设备状态和I/O操作完成情况及时的反应给请求I/O的进程。 驱动程序与设备控制器和I/O设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。 例如，可以为相同的多个终端设置一个终端驱动程序，但有时即使是同一类型的设备，由于其生产厂家不同，他们也可能并不完全兼容，此时也需为它们配置不同的驱动程序。 驱动程序与I/O设备所采用的I/O控制方式紧密相关。 常用的I/O控制方式是中断驱动和DMA方式，这两种方式的驱动程序明显不同，后者是按数组方式启动设备及进行中断处理。 由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言编写。目前有很多驱动程序的基本部分，已经固化在ROM中。 驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。例如，网络驱动程序正在处理一个到来的数据包时，另一个数据包可能已经到达。 设备驱动程序的处理过程不同类型的设备应有不同的设备驱动程序，但大体上它们都可以分成两部分： 能够驱动I/O设备工作的驱动程序 设备中断处理程序（处理I/O完成后的工作）。 设备驱动程序的主要任务是启动指定设备。但在启动之前，还必须完成必要的准备工作，如检测设备状态是否为“忙”等。在完成所有的准备工作后，才向设备控制器发送一条启动命令。以下是设备驱动程序的处理过程： 将抽象要求转换为具体要求 由于用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它发出抽象的要求（命令），但这些命令无法传送给设备控制器。因此就需要将这些抽象要求转换为具体要求。这一转换工作只能由驱动程序来完成，因为在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、参数和数据应分别送往哪个寄存器。如:将逻辑盘块号转换为具体的盘面、磁道和扇区 检查I/O请求的合法性 如:打印机请求读, 以读方式打开磁盘后请求写 读出和检查设备的状态 如:读出并检查状态是否为就绪, 确定启动控制器或等待 传送必要的参数 对于许多设备，特别是块设备，除必须向其控制器发送启动命令外，还需传送必要的参数。例如在启动磁盘进行读/写之前，应先将本次要传送的字节数和数据应到达的主存始址，送入控制器的相应寄存器中。 工作方式的设置 如:异步通信, 先设置波特率、校验方式、停止位等 启动I/O设备 驱动程序发出I/O命令后，基本的I/O操作是在设备控制器的控制下进行的。通常，I/O操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时驱动（程序）进程把自己阻塞起来，直到中断到来时才将它唤醒。 当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下: I/O控制方式设备管理的主要任务之一是控制设备和内存或处理机之间的数据传送。对I/O设备的控制，随着软硬件的发展前后出现过如下的控制方式：使用轮询的可编程I/O方式，使用中断的可编程I/O方式，直接存储器访问（DMA）方式，I/O通道控制方式. 前两种是以字节为单位进行数据传递，后两种是以数据块为单位进行数据传递。下面对这些方式进行介绍。 程序直接控制方式该图是展示了程序I/O方式的流程。 以完成一次读操作为例程序直接控制的流程： CPU通过控制线向I/O控制器发出一个读指令，I/O控制器会根据CPU的要求启动相应的设备，并将这个设备相应的状态设置为1，表示设备忙碌（未就绪）。 接下来设备就准备CPU想要读入的数据，但是由于设备和CPU处理速度的差异，所以在设备还没有完成I/O之前，CPU会一直不断的轮询检查设备的状态，即状态寄存器的值。其实就是在不在的执行程序的循环，若状态为一直是1，说明设备还没有准备好要输入的数据，于是CPU会不断轮询。 如果设备已经准备好了输入的数据，设备会向I/O控制器传送要输入的数据，并且报告自身的状态是已就绪状态。 之后I/O控制器将要输入的数据放到数据寄存器中，并且将状态寄存器的值改为0（已就绪）。 在状态寄存器改为0时，CPU轮询检查到了数据已经准备好了，设备已就绪，即可将数据寄存器中的内容读入CPU自己的寄存器中，再把寄存器的内容放入内存（数据从设备到内存需要经过CPU）。这样就完成了一次读操作。 由于CPU速度远远快于I/O设备，因此CPU需要不断地测试I/O设备，这种控制方式又称为轮询或忙等。 可以看出，缺点是CPU利用率相当低，由于CPU速度远远快于I/O设备，致使绝大部分时间都在测试I/O设备是否已经完成数据传输，从而造成CPU的极大浪费。另外，每个字的读/写都需要CPU的帮忙。 中断控制方式 该图是展示中断驱动I/O方式的流程。 引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/0的进程阻塞，先切换到别的进程执行。 以数据输入为例，当用户进程需要输入数据时，由处理器向设备控制器发出一条I/O指令启动设备进行输入。在输入数据的同时，CPU可以做其他工作。当输入完成时，设备管理器向CPU发出一个中断信号，CPU接收到中断信号以后，转去执行设备中断处理程序。设备终中断处理程序将输入数据寄存器中的数据传送到内存的指定单元中，供要求输入的进程使用，然后再启动设备去读下一个数据。 优点：有了中断硬件的支持后，CPU与I/O设备之间可以并行工作，CPU只需要收到中断后处理即可，大大提高了CPU利用率。 缺点：如果每台设备每输入/输出一个数据，都要求中断CPU，这样在一次数据传送过程中的中断次数太多，从而耗费大量CPU时间。设备与CPU之间的数据交换仍以字（节）为单位。 直接存储器访问（DMA）方式DMA方式的进入：为了适应一次传送大量数据的应用要求，以及尽量减少CPU对高速外设的干预。与“中断驱动方式”相比，DMA（Direct Memory Access，直接存储器存取。主要用于块设备的I/O控制）有这样几个改进： 数据传送的单位是块，不再是一个字一个字的传送。 数据的流向是从设备直接放入内存，或者直接从内存到设备，不再需要CPU干预。 仅在一个块或多个块的开始和结束时，才需要CPU干预。 DMA控制器的组成DMA控制器组成：主机（CPU）—控制块的接口、I/O控制逻辑、块设备—控制器接口。 命令/状态寄存器CR：用于存放CPU发来的I/O命令，或设备的状态信息。 内存地址寄存器MAR：在设备向内存输入数据时，MAR表示输入的数据应该存放到内存的什么位置，在内存向设备输出数据时，MAR表示要输出的数据放在内存的什么位置。 数据寄存器DR:暂存从设备到内存，或者从内存到设备的数据。 数据计数器DC:表示剩余要读/写的字节数。 DMA工作过程 该图就是DMA工作过程。 以数据输入为例，当用户进程需要输入数据时，CPU将准备存放数据的内存起始地址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器和传送字节计数器中，并启动设备开始进行输入。 在输入数据的同时，CPU可以去做其他事情，输入设备不断地挪用CPU工作周期，将数据寄存器中的数据源源不断地写入内存，直到要求传送的数据全部传输完毕。 DMA控制器在传输完毕时向CPU发送一个中断信号，CPU收到中断信号后转中断处理程序，中断结束后返回被中断程序。 DMA控制方式的特点为：数据传输的基本单位是数据块，而且数据是单向传输，从设备到内存或者相反。仅在传送一个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在控制器的控制下完成。 优点：设备和CPU可以并行工作，同时设备与内存的数据交换速度更快，并且不需要CPU干预。 缺点：数据传送的方向、存放输入数据的内存起始地址及传送数据的长度等都由CPU控制，并且每台设备都需要一个DMA控制器，当设备增加时，多个DMA控制器的使用也不经济。 I/O通道控制方式为了进一步减少CPU对I/O操作的干预，引入了通道。 通道控制方式与DMA类似，也是一种以内存为中心，实现设备与内存直接数据交换的控制方式。与DMA相比，通道需要的CPU干预更少，即把对一个数据块的读写为单位的干预减少为对一组数据块读写为单位的干预，而且可以做到一个通道控制多台设备。 通道本质上是一个简单的处理器，它独立于CPU，有运算和逻辑，有自己的指令系统，也在程序控制下工作，专门负责输入、输出控制，具有执行I/O指令的能力，并通过执行通道I/O程序来控制I/O操作。通道的指令系统比较简单，一般只有数据传送指令、设备控制指令等。 在通道控制方式中，CPU只需要发出启动指令，指出要求通道执行的操作和使用的I/O设备，该指令就可以启动通道并使该通道从内存中调出相应的通道程序执行。 通道控制工作方式 以数据输入为例，当用户进程需要输入数据时，CPU发出启动指令指明要执行的I/O操作、所使用的设备和通道。 当对应通道接收到CPU发来的启动指令后，把存放在内存中的通道程序读出，并执行通道程序，控制设备将数据传送到内存中指定的区域。在设备进行输入的同时，CPU可以去做其他事情。 当数据传送结束后时，设备控制器向CPU发送一个中断请求，CPU收到中断信号后转中断处理程序，中断结束后返回被中断程序。 优点：解决了I/O操作的独立性和各部件工作的并行性。不仅能实现CPU与通道的并行操作，而且通道与通道之间也能实现并行操作，各个通道上的外设也能实现并行操作，从而提高了整个系统效率。 缺点：需要更多硬件（通道处理器），成本较高，常用于大型数据交互的场合。 小结]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针2]]></title>
    <url>%2Funcategorized%2F%E6%8C%87%E9%92%882%2F</url>
    <content type="text"><![CDATA[指针除了可以和一维数组、二维数组进行结合，也可以作为函数的返回值或者指向一个函数。下面就从这两个方面入手，看看指针与函数的有趣结合。 指针作为函数返回值函数作为C语言的基本组成模块，包括函数首部和函数体两部分。函数首部由函数返回值类型、名字、参数类型、参数等组成；函数体又可以分为说明语句与执行语句。 12345返回值类型 函数名(形参类型 形参)//函数首部&#123; //函数体 说明语句 执行语句&#125; 其中返回值类型除了几种基本数据类型以外，还可以返回一个指针值，则该函数就称为指针类型的函数。例如： int *fun(int x) 该函数名为fun，fun两侧的运算符分别为“”和“()”，由于“()”的优先级高于“”，故fun()首先代表一个函数，然后与前面的“*”结合，表示返回值是一个指针，而int则表示该指针指向的数据类型为整型，即返回值为指向整型变量的指针类型。常见的返回指针值的函数有字符串复制函数。 123456789101112char *strcpy(char *s1,char *s2)&#123; char *p=s1; while(*s1++=*s2++); return p;&#125;void main()&#123; char s[20]=&quot;welcome&quot;; printf(&quot;%s\n&quot;,strcpy(s,&quot;you&quot;));&#125; 运行结果为： you 指针指向一个函数在说明这个问题之前，先对函数在内存中的存储做个简单的介绍。指针之所以可以指向函数，是因为函数被分配在代码区一段连续的内存里面，函数名称存储的为该内存块的入口地址，故可以使用指针来调用函数。当函数被调用时，函数的形参从右至左依次压入栈中，且连续。因此对于不确定参数个数的函数，只要取得了第一个形参的地址，就可以依次取得后面参数的值。这也是printf函数能够格式化打印任意个数变量值的原因，其参数从右至左依次压栈，输出时从左至右依次弹出。下面以求n个数的最大值为例: 123456789101112int max(int n,int ...)&#123; int maxnum = *(&amp;n+1); for(int i=2;i&lt;=n;i++) &#123; if(maxnum&lt;(*(&amp;n+i))) maxnum = *(&amp;n+i); &#125; return maxnum;&#125; 其中n为要输入参数的个数，(&amp;n+1)就得到了第一个待比较数字的值，(&amp;n+i)就得到了第i个待比较数字的值，i一直取到n。 下面继续，指向函数的指针变量的定义如下： int (*p)(); 首先(*p)说明p是一个指针变量，后面的()则代表了该指针指向为某一个函数，而int代表了该函数的返回值后为整型。使用函数对该指针变量进行赋值操作： p = funname; 则可以使用(*p)代替函数名funname进行函数调用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2Funcategorized%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针重要吗指针在C语言中占据着重要的地位，指针有效的取代了在低端语言（如汇编语言与机器代码）直接使用内存地址。指针又比较贴近硬件，编译器能够很容易的将指针翻译为机器代码，这使指针操作时的计算机负担较少，同时简化一些C语言编程任务，能够提高程序的运作速度。 正是由于比较贴近硬件，并且指针可以与C语言中的其他数据结构（如数组、链表、结构体、函数）进行结合，可以说是贯穿了整本C语言。使得对于初学计算机编程的人理解起来有些难度。本文将结合图像和示例对指针的知识进行整理汇总，记录指针的学习过程，让指针也变得简单起来。 指针的定义指针（英语：Pointer）在百科中给出的定义是编程语言中的一类数据类型及其对象或变量，用来表示或存储一个存储器地址，这个地址的值直接指向（points to）存在该地址的对象的值。 从这个定义中可以得到以下信息，首先指针也是一种数据类型，就像我们前面学到的int,char,float,double等基础数据类型。同样的指针也可以像其他基础数据类型一样定义变量，不同的地方在于指针变量中保存的是一个存储器的地址。（补充：程序中所有的数据都是存储在内存中的，内存被分成一个个的内存单元，每个内存单元又有一个地址。系统内存就像是带有门牌号的小房间，如果要使用某个房间，就需要得到房间的门牌号。而指针变量存储的就是门牌号，即也就是存储器地址）。指针定义变量的方式如下： 123456int *a,b=5;char *c,d=&apos;m&apos;;float *f,g=6.0;a = &amp;b;c = &amp;d;f = &amp;g; int *为整型指针数据类型，定义了一个存储整型变量存储地址的指针变量a char *为字符型指针数据类型，定义了一个存储字符型变量存储地址的变量c float *为单精度浮点型指针数据类型，定义了一个存储浮点型变量存储地址的变量f 指针变量的赋值两个指针运算符： 地址运算符&amp;取内存中变量的地址，例如&amp;b,值为整型变量b的内存地址。 取值运算符* 获取指针变量所指向变量的值，例如a,值为5。（注意与int *中的\相区别） a = &b;代表取出整型变量b的地址赋值给a，图中简单表示为2000赋值给a,即a指向变量b,a中存储了变量b的内存地址2000。指针变量c和f的赋值也一样如图所示。 这里要区分两个容易混淆的概念： 指针的类型指针的类型是指针变量本身的类型，指针变量在内存中占据4个字节，存储32位的内存地址码。 指针变量a的类型为int * 指针变量c的类型为char * 指针变量f的类型为float * 指针指向的类型指向的类型是当前指针存储的内存地址中所存储变量的类型。 a指向的类型为int c指向的类型为char f指向的类型为float 指针与一维数组我们都知道数组名是代表数组首元素地址的符号常量，而指针变量又可以存储地址，所以数组不仅可以通过数组名+下标的方式访问，也可以通过指向它的指针变量来访问。 指向数组的指针变量我们前面定义的指针变量都是指向一个基础数据类型的变量，指向数组的指针变量定义方式也类似。 12int c[5];int *p = c; 表达式(p+1)或(c+1)都代表数组元素c[1]，其中p+1和c+1都代表c[1]的地址&amp;c[1]。 数组名称c为常量，故任何对数组名称赋值的操作都是错误的。 C语言不会对地址操作做越界检查，故数组越界不会报错，这也是程序容易出错的地方。 12int (*p)[5];int *p[5]; 上面第一个定义方式为，首先计算()，*p代表p是一个指针变量，然后是[5],代表p指向一个大小为5的数组，最后int，代表p指向的是一个存储整型变量的数组。即定义数组指针p，指向一个存储5个整型元素的数组。 [5]的优先级要高于*，故p首先是一个大小为5的数组，其存储的数据类型为指针变量，而指针指向的数据类型为整型int。 指针与二维数组定义二维整型数组如下 1int a[3][3] = &#123;&#123;14,16,19&#125;,&#123;22,55,88&#125;,&#123;33,54,32&#125;&#125;; 二维数组a的元素是按行进行存储的，可以将a数组的3行看成3个分数组：a[0],a[1],a[2]。每个分数组是含3个列元素的一维数组。如下图所示： 数组名a是指向0号分数组的指针常量，值为2000，同样不能够给a赋值。a+0，a+1，a+2则分别表示0号分数组，1号分数组，2号分数组，对应存储器地址值为2000，2004，2008。其中a[0],a[1],a[2]为三个一维分数组的数组名称，这三个数组名存储的地址又分别指向a[0][0],a[1][0],a[2][0]，对应的数值为3000，3006，3012。a[0]+1和a[0]+2则是分别指向a[0][1],a[0][2]的指针常量,对应的地址值为3002，3004。 虽然a与a[0]的地址都是2000，但是并不等价，a的基类型字节数为4，a[0]为2，也可以从a+1与a[0]+1的不同结果看出。以下是二维数组不同表示形式的含义与内容：]]></content>
  </entry>
  <entry>
    <title><![CDATA[ARP网关欺骗]]></title>
    <url>%2Funcategorized%2FARP%E7%BD%91%E5%85%B3%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[大家好，唐三藏奉旨投西，我是随行记者小唐。就在前几日，孙行者因故打死几个剪径的强盗，唐长老盛怒之下将其赶走。正好让六耳猕猴钻了空子，打昏了三藏，夺走了行李。沙悟净前去索要，竟被六耳猕猴告之他要自行前去取经。悟净不以为然，言道：“老哥啊，没有唐僧去，哪个佛祖都不会传经给你，你这才是白忙活哩。”六耳道：“贤弟啊，你一直就挺懞懂，不太了解情况。其实啊，我这已经人员齐备，整装待发了，你来看。”说着便请出来一匹白马，一个唐三藏，跟着一个八戒，一个沙僧。从后来事态发展的情况来看，六耳的取经队伍恐怕是瞒不过佛祖，自然也无法取来真经。但是如果将真经类比为数据包，六耳猕猴类比为ARP攻击程序，在计算机网络的世界中，这却是特别容易成功的。那这究竟是怎么一回事呢？ARP又是什么呢？ 以太网络别忙，解释这些问题之前，我们先来简单回顾一下计算机之间时如何进行联系的。首先整个计算机网络是由一个又一个的子网所构成，子网可以简单理解为所有连接同一个路由器的计算机所构成。在同一个子网内的计算机，相互之间是可以直接进行通信的，使用的是以太协议，又叫以太网。但是如果想同另一个子网的计算机进行通信就必须经过路由器，此时的路由器又可以叫做网关。在局域网中通信时使用的是MAC地址，而不是常见的IP地址。所以在局域网的两台主机间通信时，必须要知道对方的MAC地址，这就是ARP协议要做的事，将IP地址转换为MAC地址。 通过 ARP 查询目标路由器的 MAC 地址ARP 就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”然后就会有设备回答：“这个 IP 地址是我的，我的 MAC 地址是××××。”如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。 ARP缓存如果每次发送包都要这样查询一次，网络中就会增加很多 ARP包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用。也就是说，在发送包时，先查询一下 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址，而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询。 ARP欺骗ARP攻击程序就是一直在应答：“这个 IP 地址（其实是网关的IP地址）是我的，我的 MAC 地址是××××。”这是时候其他设备就会将该设备当作网关，所有的与其他子网交互的数据都会发到该设备，从而实现了ARP欺骗，就会出现无法上网或者数据泄露的风险。使用kali Linux 的arpspoof工具可以轻松实现这一功能。命令参数如下： arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host(-i指定网卡接口，-t指定目标机器，-r当前网关)]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言版本之谜]]></title>
    <url>%2FC%2FC%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E4%B9%8B%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[赋闲在家，可能反而给了我们更多的时间来进行思考。偶然看到一段蛮有吸引力的视频，视频在文章的末尾，只有十分钟，即使是鸡汤，感觉也是一碗可以榨取出营养的鸡汤。 为什么大多数人不能成功作者提出，为什么大多数人都不会真正的成功？我们周围的环境都在试图将我们拉向平庸，并且引力非常大，而且我们中的大多数人都无法摆脱这些诱惑。 这些诱惑可以使你的大脑感到愉悦，甚至有的诱惑还能欺骗我们自己的大脑，让我们自己感觉到自己在学习东西，从而减少一些无所事事的负罪感。我们以电子媒介中的新闻为例，这个电子媒介勾画的世界不存在秩序和意义，我们不必把它当回事。再残忍的谋杀，再具破坏力的地震，再严重的政治错误，只要新闻播音员说一声“好，现在我们看下一篇报道”，一切就可以马上从我们的脑海中消失。新闻播音员意思是我们为上一条新闻花费的时间已经够多了，不必一直念念不忘，应该将注意力转移到下一篇新闻了。在这里我们看到的不仅是零散不全的新闻，而且没有背景，没有结果，更加没有价值，新闻成了纯粹的娱乐。 信息过剩我们每天刷着手机，接受海量的信息，几天下来，可能比古人一辈子获得的信息都要多了。但是能够对我们有价值，能够促成我们行动的信息却少之又少。我们可能一辈子都无法参与到中东的军事行动，英国脱欧的政治博弈，顶多在与朋友闲聊的时候多说两句话。新闻尚如此，可见我们每天对着手机和电脑会遇到多少诱惑。当我们获得了有价值的信息，打算有所行动的时候，会开始惧怕失败。 惧怕失败作者讲的第一个原因就是人们会本能的惧怕失败，在他们眼里如果他们把一件事情搞砸了，那就意味着他们本身就很糟糕，任何失败都会证明他们不够好。但是你可以从失败中获得气馁，也可以从中获得经验。避免了失败也就失去了许多获得经验的机会。这里很多人会说，人们惧怕失败是因为有的人根本承担不起失败的后果。没错，但是生活中不一定都是一些大事情，还有一些小事情，比如作者说的写博客的例子。 花时间去比较作者还提到不要过多的关注别人，嫉妒别人。如果你关注别人过多，就会容易失去自我，你的价值和行动会很难保持一致，这会让你感到空虚和不快乐。作者还说了一句很有道理的话，“嫉妒和怨恨就像自己喝下毒药，却期待别人死去一样”。我们中的大多数人都会选择娱乐和消遣，而不是学习和成长，因为后者很难。遇到困难应该感到高兴，因为这意味着大多数人都不会选择做这件事，竞争并不激烈。 希望作者的视频能够促成你的某些行动。不然就是一碗没有意义的鸡汤了。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CRC校验算法JAVA版]]></title>
    <url>%2FIot%2Fcrc-java%2F</url>
    <content type="text"><![CDATA[CRC校验又称为循环冗余校验，是数据通讯中常用的一种校验算法。它可以有效的判别出数据在传输过程中是否发生了错误，从而保障了传输的数据可靠性。 CRC16 Modbus校验算法JAVA版 1234567891011121314151617181920212223242526272829303132333435//大端对齐 static byte[] crc16_tab_h = &#123; (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40 &#125;; //小端对齐 static byte[] crc16_tab_l = &#123; (byte) 0x00, (byte) 0xC0, (byte) 0xC1, (byte) 0x01, (byte) 0xC3, (byte) 0x03, (byte) 0x02, (byte) 0xC2, (byte) 0xC6, (byte) 0x06, (byte) 0x07, (byte) 0xC7, (byte) 0x05, (byte) 0xC5, (byte) 0xC4, (byte) 0x04, (byte) 0xCC, (byte) 0x0C, (byte) 0x0D, (byte) 0xCD, (byte) 0x0F, (byte) 0xCF, (byte) 0xCE, (byte) 0x0E, (byte) 0x0A, (byte) 0xCA, (byte) 0xCB, (byte) 0x0B, (byte) 0xC9, (byte) 0x09, (byte) 0x08, (byte) 0xC8, (byte) 0xD8, (byte) 0x18, (byte) 0x19, (byte) 0xD9, (byte) 0x1B, (byte) 0xDB, (byte) 0xDA, (byte) 0x1A, (byte) 0x1E, (byte) 0xDE, (byte) 0xDF, (byte) 0x1F, (byte) 0xDD, (byte) 0x1D, (byte) 0x1C, (byte) 0xDC, (byte) 0x14, (byte) 0xD4, (byte) 0xD5, (byte) 0x15, (byte) 0xD7, (byte) 0x17, (byte) 0x16, (byte) 0xD6, (byte) 0xD2, (byte) 0x12, (byte) 0x13, (byte) 0xD3, (byte) 0x11, (byte) 0xD1, (byte) 0xD0, (byte) 0x10, (byte) 0xF0, (byte) 0x30, (byte) 0x31, (byte) 0xF1, (byte) 0x33, (byte) 0xF3, (byte) 0xF2, (byte) 0x32, (byte) 0x36, (byte) 0xF6, (byte) 0xF7, (byte) 0x37, (byte) 0xF5, (byte) 0x35, (byte) 0x34, (byte) 0xF4, (byte) 0x3C, (byte) 0xFC, (byte) 0xFD, (byte) 0x3D, (byte) 0xFF, (byte) 0x3F, (byte) 0x3E, (byte) 0xFE, (byte) 0xFA, (byte) 0x3A, (byte) 0x3B, (byte) 0xFB, (byte) 0x39, (byte) 0xF9, (byte) 0xF8, (byte) 0x38, (byte) 0x28, (byte) 0xE8, (byte) 0xE9, (byte) 0x29, (byte) 0xEB, (byte) 0x2B, (byte) 0x2A, (byte) 0xEA, (byte) 0xEE, (byte) 0x2E, (byte) 0x2F, (byte) 0xEF, (byte) 0x2D, (byte) 0xED, (byte) 0xEC, (byte) 0x2C, (byte) 0xE4, (byte) 0x24, (byte) 0x25, (byte) 0xE5, (byte) 0x27, (byte) 0xE7, (byte) 0xE6, (byte) 0x26, (byte) 0x22, (byte) 0xE2, (byte) 0xE3, (byte) 0x23, (byte) 0xE1, (byte) 0x21, (byte) 0x20, (byte) 0xE0, (byte) 0xA0, (byte) 0x60, (byte) 0x61, (byte) 0xA1, (byte) 0x63, (byte) 0xA3, (byte) 0xA2, (byte) 0x62, (byte) 0x66, (byte) 0xA6, (byte) 0xA7, (byte) 0x67, (byte) 0xA5, (byte) 0x65, (byte) 0x64, (byte) 0xA4, (byte) 0x6C, (byte) 0xAC, (byte) 0xAD, (byte) 0x6D, (byte) 0xAF, (byte) 0x6F, (byte) 0x6E, (byte) 0xAE, (byte) 0xAA, (byte) 0x6A, (byte) 0x6B, (byte) 0xAB, (byte) 0x69, (byte) 0xA9, (byte) 0xA8, (byte) 0x68, (byte) 0x78, (byte) 0xB8, (byte) 0xB9, (byte) 0x79, (byte) 0xBB, (byte) 0x7B, (byte) 0x7A, (byte) 0xBA, (byte) 0xBE, (byte) 0x7E, (byte) 0x7F, (byte) 0xBF, (byte) 0x7D, (byte) 0xBD, (byte) 0xBC, (byte) 0x7C, (byte) 0xB4, (byte) 0x74, (byte) 0x75, (byte) 0xB5, (byte) 0x77, (byte) 0xB7, (byte) 0xB6, (byte) 0x76, (byte) 0x72, (byte) 0xB2, (byte) 0xB3, (byte) 0x73, (byte) 0xB1, (byte) 0x71, (byte) 0x70, (byte) 0xB0, (byte) 0x50, (byte) 0x90, (byte) 0x91, (byte) 0x51, (byte) 0x93, (byte) 0x53, (byte) 0x52, (byte) 0x92, (byte) 0x96, (byte) 0x56, (byte) 0x57, (byte) 0x97, (byte) 0x55, (byte) 0x95, (byte) 0x94, (byte) 0x54, (byte) 0x9C, (byte) 0x5C, (byte) 0x5D, (byte) 0x9D, (byte) 0x5F, (byte) 0x9F, (byte) 0x9E, (byte) 0x5E, (byte) 0x5A, (byte) 0x9A, (byte) 0x9B, (byte) 0x5B, (byte) 0x99, (byte) 0x59, (byte) 0x58, (byte) 0x98, (byte) 0x88, (byte) 0x48, (byte) 0x49, (byte) 0x89, (byte) 0x4B, (byte) 0x8B, (byte) 0x8A, (byte) 0x4A, (byte) 0x4E, (byte) 0x8E, (byte) 0x8F, (byte) 0x4F, (byte) 0x8D, (byte) 0x4D, (byte) 0x4C, (byte) 0x8C, (byte) 0x44, (byte) 0x84, (byte) 0x85, (byte) 0x45, (byte) 0x87, (byte) 0x47, (byte) 0x46, (byte) 0x86, (byte) 0x82, (byte) 0x42, (byte) 0x43, (byte) 0x83, (byte) 0x41, (byte) 0x81, (byte) 0x80, (byte) 0x40 &#125;; public byte[] calcCrc16(byte[] data, int offset, int len) &#123; return calcCrc16(data, offset, len, 0xffff); &#125; public byte[] calcCrc16(byte[] data, int offset, int len, int preval) &#123; int ucCRCHi = (preval &amp; 0xff00) &gt;&gt; 8; int ucCRCLo = preval &amp; 0x00ff; int iIndex; for (int i = 0; i &lt; len; ++i) &#123; iIndex = (ucCRCLo ^ data[offset + i]) &amp; 0x00ff; ucCRCLo = ucCRCHi ^ crc16_tab_h[iIndex]; ucCRCHi = crc16_tab_l[iIndex]; &#125; int value = ((ucCRCHi &amp; 0x00ff) &lt;&lt; 8) | (ucCRCLo &amp; 0x00ff) &amp; 0xffff; return int2Bytes(value,2); &#125; public byte[] int2Bytes(int value, int length) &#123; byte[] b = new byte[length]; for (int k = 0; k &lt; length; k++) &#123; b[length - k - 1] = (byte) ((value &gt;&gt; 8 * k) &amp; 0xff); &#125; return b; &#125; CRC16查表算法代码采用的多项式为CRC-16/IBM： X16+X15+X2+1C语言版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static uint16_t const CRC16Table[256] = &#123; 0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040&#125;;uint16_t CRC16(uint8_t* dataIn, int length)&#123; uint16_t result = 0; uint16_t tableNo = 0; for(int i = 0; i &lt; length; i++) &#123; tableNo = ((result &amp; 0xff) ^ (dataIn[i] &amp; 0xff)); result = ((result &gt;&gt; 8) &amp; 0xff) ^ CRC16Table[tableNo]; &#125; return result; &#125; JAVA版： 123456789101112131415161718192021222324252627282930313233//小端对齐 private static final int[] CRC16Table = &#123; 0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040 &#125;;public byte[] CRC16(byte[] bytes) &#123; int result = 0xFFFF; int tableNo = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; tableNo = ((result &amp; 0xff) ^ (bytes[i] &amp; 0xff)); result = ((result &gt;&gt; 8) &amp; 0xff) ^ CRC16Table[tableNo]; &#125; return int2Bytes(result, 2); &#125;]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>编解码</tag>
        <tag>CRC校验算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网体系结构]]></title>
    <url>%2FIot%2Fiot-architecture%2F</url>
    <content type="text"><![CDATA[目前国内物联网通信领域，主要分为两大阵营：以三大运营商和华为为主的NB通信方式，以阿里巴巴和Lora联盟为主的Lora和LoraWan通信方式（还有传统的GPRS通信方式和SMS通信方式）。 NB借用运营商已有的基站作为网络节点发送数据，而Lora多用于自组网，需要自行搭建网关。两种方式各有优缺点。例如有些共享单车就采用了短信（SMS）+NB+蓝牙的通信方式。其中NB通信方式多采用Coap协议进行。Coap协议是基于UDP的应用层协议，较Http轻量，专为物联网终端设计，采用无状态连接。因为采用无状态连接故Coap并不擅长主动下发命令。Mqtt协议基于TCP协议，有商业和开源的mqtt broker供选择，支持ACL访问控制、集群、共享订阅等高级功能，能够实现实时命令下发，相较于TCP协议大大简化服务器端的开发工作量。采用NB通信方式需要从电信运营商处采购物联卡，并且开通NB流量套餐。目前三大运营商皆有物联卡。 为了方便管理设备的连接，通信协议的解析，以及设备的鉴权，各大运营商都推出了自己的Iot平台。比如中国移动的OneNet平台，华为的OceanConnect平台，以及中国电信在OceanConnect平台基础上，开发出的中国电信Iot平台。目前OceanConnect平台为收费使用且价格不菲，中国电信则免费使用，但是限制只能够使用中国电信的物联卡，且中国电信的物联卡也只能将数据发送到中国电信Iot平台，实现了双向绑定。中国移动的物联卡目前没有这一限制，并且可以使用GPRS（2G\3G\4G\4G+）通信方式。 Iot平台都自带设备接入功能，设备状态管理功能，提供了通信协议解析的接口。用户可根据终端设备的通信协议，安装平台接口标准自行编写编解码插件用于数据的解析，即将Hex格式的数据解析为json格式，反之亦然。Iot平台与用户应用平台的交互也都提供了api接口，用户在应用平台调用对应的接口即可。关于解析好的数据，可以通过订阅/推送的方式发送到应用平台，也可以应用平台通过接口主动请求获取数据。]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>物联网通信</tag>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络是个邮局]]></title>
    <url>%2FComputer-Networking%2FHistory-of-Computer-Networking%2F</url>
    <content type="text"><![CDATA[网络网络（network）是一组具有通信能力的设备相互连接而形成的。在这个定义中，设备可以是主机（host）,也可以是连接设备，如连接网络到其他网段的路由器（routers）、将设备连接到一起的交换机、对电信号进行数模转换的调制解调器等。 局域网局域网（LAN）通常是私有的，连接一个办公室、大楼或校园内的一些主机。 广域网广域网（WAN）也是由具有通信能力的设备相互连接而形成的。局域网通常覆盖范围受限，广域网则具有更广的地理覆盖范围。 网络是个邮局试想一下，假如你开发了一套应用软件，这些运行在不同终端系统上（计算机、手机、平板）的程序，相互之间需要传输数据。那么运行在一台终端上的程序是如何使用网络设备（网卡、交换机、路由器）将数据传输给另外一台终端上的程序呢？ 实际上计算机（其他终端相同）提供了一套支持多种通信协议的网络通信接口（socket interface），该通信接口明确了，运行在计算机上的程序如何让网络设备将数据发送到另外一台设备。即该网络通信接口制定了一种规则，应用程序必须遵守该规则，才能顺利将数据发送到目标程序。举个例子：艾家庄的艾丽丝小姐想要通过邮局给鲍家庄的鲍博先生写一封信。当然艾丽丝把信写好以后，不能就随手把信往窗外一扔，然后万事大吉，这样鲍博永远也收不到信件。正确的做法是，邮局需要艾丽丝将信装在一个信封里面，信封上写上鲍博的名字、家庭地址、邮政编码，贴上一个邮票。最后把信封投进附近的邮箱里面，这样就能发信件发出去了。因此，邮局提供了一套邮寄信件的“通信接口”，或者说制定了一套规则。艾丽丝必须遵守邮局制定的邮寄信件规则，才能成功将信邮给鲍博。同样，网络也有自己的通信规则（socket interface），应用程序想通过网络发送数据也必须遵守这种规则。当然邮局不止提供一种邮寄信件的服务，同样网络也支持各种协议。 什么是协议协议定义了两个或多个通信实体之间交换的消息的格式和顺序，以及在消息或其他事件的传输或接收上采取的动作。 文章参考自Computer networking: a top-down approach seventh edition。]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>计算机网络 Internet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题开启文章分享功能及去除图片上的分享按钮]]></title>
    <url>%2FHexo%2F2019062712%2F</url>
    <content type="text"><![CDATA[Hexo的Next主题中已经集成了文章分享功能，我们只需要clone下github上的分享插件，并修改Next主题配置文件就可以实现文章的分享功能。具体操作如下。 配置Next主题配置文件打开主题配置文件检索baidushare配置如下： 12345678910111213141516171819baidushare: type: slideneedmoreshare2: enable: true postbottom: enable: true options: iconStyle: true boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 下载文章分享所需插件配置文件中已经给出了文章分享所需插件的github仓库地址，即 https://github.com/theme-next/theme-next-needmoreshare2仓库中也给出了使用方法，即首先通过命令行进入themes/next主题目录下，然后将插件clone下来： 12$ cd themes/next$ git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 后期需要更新的话就是通过以下命令： 12$ cd themes/next/source/lib/needsharebutton$ git pull 至此，我们就可以在文章的尾部看到分享文章的按钮了。但是当我把鼠标放在文章中的图片上时，发现图片的右上角也加上了一排分享的按钮，经过分析，找到了添加分享的代码，将其注释一下就大功告成了，实现清清爽爽的页面。找到路径为themes\next\layout_partials\share\baidushare.swig的文件，将代码中的image注释掉。大约在26-30行，代表设置分享按钮在文章底部时的效果；42-46行，代表设置文章分享按钮在侧边时的效果。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;script&gt; window._bd_share_config = &#123; "common": &#123; "bdText": "", "bdMini": "2", "bdMiniList": false, "bdPic": "" &#125;, "share": &#123; "bdSize": "16", "bdStyle": "0" &#125;, // "image": &#123; // "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"], // "viewText": "分享到：", // "viewSize": "16" // &#125; &#125; &lt;/script&gt;&#123;% elif theme.baidushare.type === "slide" %&#125; &lt;script&gt; window._bd_share_config = &#123; "common": &#123; "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "" &#125;, // "image": &#123; // "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"], // "viewText": "分享到：", // "viewSize": "16" // &#125;, "slide": &#123; "bdImg": "5", "bdPos": "left", "bdTop": "100" &#125; &#125; &lt;/script&gt; 注释掉以后执行Hexo g重新生成页面（记得cd .. 退回到Hexo博客的根目录欧），就可以看到图片上已经没有分享按钮了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地Git关联Github]]></title>
    <url>%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F2019062616%2F</url>
    <content type="text"><![CDATA[本地git关联github1.输入你的github注册邮箱,生成本地ssh key $ ssh-keygen -t rsa -C “your_email@youremail.com“ 2.然后成功后会在User文件夹对应的用户下创建.ssh文件夹，其中有一个id_rsa.pub文件，我们复制其中的key,进入 Account Settings（账户配置），左边选择SSH and GPG Keys选项。其中的title随便填，下面的粘贴在你电脑上生成的key。 3.验证是否绑定本地成功，在git-bash中验证，输入指令： $ ssh -T git@github.com 如果第一次执行该指令，则会提示是否continue继续，如果我们输入yes就会看到成功信息： 4.由于GitHub每次执行commit操作时，都会记录username和email，下面进行设置： $ git config –global user.name “name”//你的GitHub登陆名$ git config –global user.email “123@163.com“//你的GitHub注册邮箱 5.在github上新建一个仓库，并添加一个README.md文件，并pull到本地： $ git pull “仓库的ssh链接” 6.常用git命令 git init //把这个目录变成Git仓库git add README.md //文件添加到仓库git add . //不但可以跟单一文件，还可以跟通配符，添加当前目录下所有文件git commit -m “first commit” //把文件提交到本地仓库git remote add origin git@github.com:yourname/youremail.git //关联远程仓库git pull XXX master –allow-unrelated-histories //允许合并不相关历史的内容git push -u origin master //上传到远程仓库]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换个角度看编解码插件开发]]></title>
    <url>%2FIot%2Foceanconnect-plugin-dev%2F</url>
    <content type="text"><![CDATA[编解码概述书写编解码插件之前首先需要书写Profile文件，定义如下。 Profile文件用于描述一款设备的能力特性。IOT平台通过解析Profile文件，获取该设备支持的服务（通信协议里面的一条完整报文）、属性（报文中的一个字段）、命令（报文中的一个字段）等信息。 IOT平台通过编解码插件，对NB设备上报的数据和下发给NB设备的命令进行格式转换，即将设备上报的16进制格式的报文转换成json，json数据的具体属性名称将由Profile文件来确定。 知识储备熟悉javase基础编程，maven项目管理工具基本命令，jackson类库。 开发工具Eclipse，jdk1.8，maven，NB设备通信协议。 编解码结构分析Profile结构Profile文件是一个深度为四级的文件夹如图所示。 红色方框中为第一级目录，目录名称为当前项目的名称，命名规则为：设备类型-厂商ID-设备型号，例如WellMonitor_Apple_A1865，对应图中功能结构中的Product模块。 绿色方框中为第二级目录，包含两个文件夹profile和service。profile文件夹下放置一个devicetype-capability.json，被用来描述一款设备的能力特征，包括设备类型、厂商、型号、协议类型以及提供的服务类型。相当于对当前整个Profile项目信息的一个概述。service文件夹下则包含设备具备的服务能力，每个服务具备的属性、命令以及命令的参数，对应图中Service模块。 蓝色方框中代表三级目录，代表具体的服务，每个服务中又包含了属性和命令，属性用于描述设备上报数据，命令用于下发指令给设备，分别对应图中的Property模块和Command模块。 此外只有红色与蓝色方框中文件的命名可以改动，其他名称固定不变。 例如图2‑1，service中包含了WellWaterCommand代表井盖+水位设备所有的下行命令；WellWaterDeviceInfo代表该设备上报的设备信息；WellWaterTiming代表该设备定时上报的信息，共计三个服务。关于如何根据设备的通信协议划分服务，将在第三章中详细介绍。 编解码插件结构编解码插件使用java开发且jdk版本必须为1.8，maven进行项目管理，建议使用eclipse开发工具。其工程目录结构如图所示。工程的命名建议和Profile项目相同，即采用：设备类型-厂商ID-设备型号的格式。其余包名类名无需更改，即使用华为提供的名称。 其中下行数据编码表示该类将平台下发的json格式的命令转化为字节数组。 上行数据解码则表示该类将设备上报的字节数组转化为json格式数据。 主类则负责调用下行数据编码或者上行数据解码。 工具类中包含了不同数据类型之间转换的方法。 编解码插件开发Profile开发新建工程新建名称为：设备类型-厂商ID-设备型号的文件夹，例如WellMonitor_Apple_A1865，打开该文件夹新建profile和service两个子文件夹，如图所示。注意profile和service这两个文件夹名称是固定不变的。 创建概述文件打开profile文件夹新建devicetype-capability.json文件，编辑该json文件如图所示。其中每个字段所代表的含义如图所示。serviceTypeCapabilitiesJson数组包含了该Profile文件所有的服务模块，即每增加一个service都需要在这个数组中添加一个对应的json对象。例如Apple公司采用CoAP协议，设备型号为A1865的井盖设备包含三个服务（功能）模块，井盖命令、井盖开机信息，井盖定时上报信息。 Service划分关于一个设备service的划分，可以采用根据设备通信协议中上报报文的功能码进行划分的方法，即协议中一条上报报文对应一个service（通常一条报文占用一个功能码）。 Service划分步骤： 将通信协议中的报文区分为上行数据和下行数据两类。 将下行数据（命令）写在一个service里面。 将上行数据根据功能码的不同，分成若干个不同的service。 创建service打开第二级目录的service文件夹，根据步骤二devicetype-capability.json文件中serviceTypeCapabilities数组中定义的service创建对应的文件夹，文件夹名称为serviceId对应的值。每个文件夹下分别创建profile文件夹，profile文件夹下创建servicetype-capability.json文件，用来描述具体服务的功能，如图所示。 接下来编写每个service对应的servicetype-capability.json，如图所示的Profile，将井盖水位设备的所有命令下发模块单独写在了一个service中，即WellWaterCommand模块；将设备的上报数据信息按照通信协议中每个报文的功能码区分为不同的service，即WellWaterDeviceInfo（开机信息）模块与WellWaterTiming（定时上报）模块。 编写下行service下行命令在service中的书写格式如图3‑5所示。Commands数组里面存放若干个命令对象，每个命令对象包含CommandName命令的名称和paras命令携带的参数数组，以及responses命令回应数组。paras数组里面包含若干个参数对象。参数对象包含paraName等一系列属性。这每一个参数对象都对应通信协议报文中的一个属性。serviceType的值一定要与当前服务文件夹名称保持一致。 编写上行service上行属性service比命令service要简单，properties数组中存放的是设备上报上来的数据，每一个json对象对应通信协议报文中的一个属性。propertyName的值可以随意定义，dataType的值如不能根据通信协议中的默认参数值明显的判断该属性的数据类型，应找相关人员确认，否则解析将会出现数据错误。 打包Profile将WellMonitor_Apple_A1865文件夹下的profile和service文件打包为zip格式，命名为WellMonitor_Apple_A1865，并且压缩包内不能包含WellMonitor_Apple_A1865文件夹这一层目录。 编解码开发使用eclipse配置本地maven仓库，并导入华为提供的demo工程。 修改pom.xml中的&lt;artifactId&gt;XXX&lt;/artifactId&gt;和&lt;Bundle-SymbolicName&gt;XXX&lt;/Bundle-SymbolicName&gt;命名规范：设备类型-厂商ID-设备型号，与Profile文件保持一致。如图所示。 修改ProtocolAdapterImpl.java中的厂商名称与设备型号，注意与Profile保持一致。如图所示。 编写下行编码数据下行编码流程如图所示，通过获取OC平台发送过来的json数据，首先根据serviceId将对应数据保存到全局变量中，然后调用toByte方法，将各种类型的数据装换为16进制的比特数组。拼装成一条完整的报文并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 编写上行解码数据上行解码流程如图所示。通过获取OC平台发送过来的16进制比特数组格式数据，首先根据比特数组中的功能码（功能码在数据哪个位置，请从通信协议中查看），将不同服务对应的不同数据，根据通信协议将byte类型的属性转换为所需类型，保存到全局变量中，然后调用toJsonNode方法，拼装成一个Json对象并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 打包编解码打包编解码，即将该maven工程打包成jar文件。检查pom.xml中的&lt;packaging&gt;bundle&lt;/packaging&gt;值是否为bundle，不能为jar。以eclipse为例，在工程上右键选择RunAs然后选择Maven build…如图所示。 在Goals中输入clean package点击Run按钮，如图所示。 等待控制台出现BUILDSUCCESS，即可在当前项目的target目录下找到打包好的jar文件，如图所示。 新建package文件夹，文件夹下包含preload文件夹以及package-info.json描述文件，将打包好的jar文件放到preload文件夹下，如图所示。 按照内容修改package-info.json描述文件，如图所示。 最后将package文件夹压缩为package.zip,并且压缩包内不能包含package文件夹这一层目录。 上传离线插件到OC开发者平台上传Profile有两种上传方式。 登录开发者门户，选择产品开发下的添加按钮。 选择从本地导入产品创建-&gt;上传Profil文件。将上文中打包好的Profile文件WellMonitor_Apple_A1865.zip进行上传。 登录管理门户，选择设备管理-&gt;产品模型-&gt;本地导入产品模型，添加完成后会自动同步到开发者门户，然后在开发者门户继续下面的上传插件操作。 上传插件上传Profile以后就会自动生成一个产品，选择第二步编解码插件开发-&gt;插件管理-&gt;上传插件。将上文中打包好的package.zip文件上传。插件上传成功，即可注册设备进行下一步的开发。附录 点击显/隐内容 Nothing to show you.]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>OceanConnect</tag>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堪比华为还详细的编解码插件线下开发教程]]></title>
    <url>%2FIot%2F%E7%BC%96%E8%A7%A3%E7%A0%81%E6%8F%92%E4%BB%B6%E4%B9%A6%E5%86%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编解码概述书写编解码插件之前首先需要书写Profile文件，定义如下。 Profile文件用于描述一款设备的能力特性。IOT平台通过解析Profile文件，获取该设备支持的服务（通信协议里面的一条完整报文）、属性（报文中的一个字段）、命令（报文中的一个字段）等信息。 IOT平台通过编解码插件，对NB设备上报的数据和下发给NB设备的命令进行格式转换，即将设备上报的16进制格式的报文转换成json，json数据的具体属性名称将由Profile文件来确定。 前期准备知识储备熟悉javase基础编程，maven项目管理工具基本命令，jackson类库。 开发工具Eclipse，jdk1.8，maven，NB设备通信协议。 编解码结构解析Profile结构Profile文件是一个深度为四级的文件夹如图3‑4所示。 红色方框中为第一级目录，目录名称为当前项目的名称，命名规则为：设备类型-厂商ID-设备型号，例如WellMonitor_Chinastar_CSiTWLM05，对应图3‑4功能结构中的Product模块。 绿色方框中为第二级目录，包含两个文件夹profile和service。profile文件夹下放置一个devicetype-capability.json，被用来描述一款设备的能力特征，包括设备类型、厂商、型号、协议类型以及提供的服务类型。相当于对当前整个Profile项目信息的一个概述。service文件夹下则包含设备具备的服务能力，每个服务具备的属性、命令以及命令的参数，对应图3‑4中Service模块。 蓝色方框中代表三级目录，代表具体的服务，每个服务中又包含了属性和命令，属性用于描述设备上报数据，命令用于下发指令给设备，分别对应图3‑4中的Property模块和Command模块。 此外只有红色与蓝色方框中文件的命名可以改动，其他名称固定不变。 例如图2‑1service中包含了WellWaterCommand代表井盖+水位设备所有的下行命令；WellWaterDeviceInfo代表该设备上报的设备信息；WellWaterTiming代表该设备定时上报的信息，共计三个服务。关于如何根据设备的通信协议划分服务，将在第三章中详细介绍。media/4e8ad1d840e65bfc32b745a7004fb776.png 图2‑1 Profile文件结构 图2‑2 Profile功能结构 编解码插件结构编解码插件使用java开发且jdk版本必须为1.8，maven进行项目管理，建议使用eclipse开发工具。其工程目录结构如图3‑4所示。工程的命名建议和Profile项目相同，即采用：设备类型-厂商ID-设备型号的格式。其余包名类名无需更改，即使用华为提供的名称。 其中下行数据编码表示该类将平台下发的json格式的命令转化为字节数组。 上行数据解码则表示该类将设备上报的字节数组转化为json格式数据。 主类则负责调用下行数据编码或者上行数据解码。 工具类中包含了不同数据类型之间转换的方法。 图2‑3 编解码插件工程结构 编解码插件开发Profile开发新建工程新建名称为：设备类型-厂商ID-设备型号的文件夹，例如WellMonitor_Chinastar_CSiTWLM05，打开该文件夹新建profile和service两个子文件夹，如图3‑4所示。注意profile和service这两个文件夹名称是固定不变的。 图3‑1 Profile文件夹 创建概述文件打开profile文件夹新建devicetype-capability.json文件，编辑该json文件如图3‑4所示。其中每个字段所代表的含义如图3‑4所示。serviceTypeCapabilitiesJson数组包含了该Profile文件所有的服务模块，即每增加一个service都需要在这个数组中添加一个对应的json对象。例如Chinstar公司采用CoAP协议，设备型号为CSiTWLM05的井盖设备包含三个服务（功能）模块，井盖命令、井盖开机信息，井盖定时上报信息。 Service划分关于一个设备service的划分，可以采用根据设备通信协议中上报报文的功能码进行划分的方法，即协议中一条上报报文对应一个service（通常一条报文占用一个功能码）。 Service划分步骤： 将通信协议中的报文区分为上行数据和下行数据两类。 将下行数据（命令）写在一个service里面。 将上行数据根据功能码的不同，分成若干个不同的service。 图3‑2 Profile概述文件 图3‑3 Profile文件字段含义 创建service打开第二级目录的service文件夹，根据步骤二devicetype-capability.json文件中serviceTypeCapabilities数组中定义的service创建对应的文件夹，文件夹名称为serviceId对应的值。每个文件夹下分别创建profile文件夹，profile文件夹下创建servicetype-capability.json文件，用来描述具体服务的功能，如图3‑4所示。 图3‑4 service文件结构 接下来编写每个service对应的servicetype-capability.json，如图3‑4所示的Profile，将井盖水位设备的所有命令下发模块单独写在了一个service中，即WellWaterCommand模块；将设备的上报数据信息按照通信协议中每个报文的功能码区分为不同的service，即WellWaterDeviceInfo（开机信息）模块与WellWaterTiming（定时上报）模块。 编写下行service下行命令在service中的书写格式如图3‑5所示。Commands数组里面存放若干个命令对象，每个命令对象包含CommandName命令的名称和paras命令携带的参数数组，以及responses命令回应数组。paras数组里面包含若干个参数对象。参数对象包含paraName等一系列属性。这每一个参数对象都对应通信协议报文中的一个属性。serviceType的值一定要与当前服务文件夹名称保持一致。 图3‑5 命令service 编写上行service上行属性service比命令service要简单，properties数组中存放的是设备上报上来的数据，每一个json对象对应通信协议报文中的一个属性。propertyName的值可以随意定义，dataType的值如不能根据通信协议中的默认参数值明显的判断该属性的数据类型，应找相关人员确认，否则解析将会出现数据错误。 打包Profile将WellMonitor_Chinastar_CSiTWLM05文件夹下的profile和service文件打包为zip格式，命名为WellMonitor_Chinastar_CSiTWLM05，并且压缩包内不能包含WellMonitor_Chinastar_CSiTWLM05文件夹这一层目录。 编解码开发使用eclipse配置本地maven仓库，并导入华为提供的demo工程。 修改pom.xml中的&lt;artifactId&gt;XXX&lt;/artifactId&gt;和&lt;Bundle-SymbolicName&gt;XXX&lt;/Bundle-SymbolicName&gt;命名规范：设备类型-厂商ID-设备型号，与Profile文件保持一致。如图3‑6、图3‑7所示。 图3‑6 pom修改厂商名称 图3‑7 pom修改厂商名称 修改ProtocolAdapterImpl.java中的厂商名称与设备型号，注意与Profile保持一致。如图3‑8所示。 图3‑8 修改Protocol文件 编写下行编码数据下行编码流程如图3‑9所示，通过获取OC平台发送过来的json数据，首先根据serviceId将对应数据保存到全局变量中，然后调用toByte方法，将各种类型的数据装换为16进制的比特数组。拼装成一条完整的报文并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 图3‑9 数据下行编码流程图 编写上行解码数据上行解码流程如图3‑10所示。通过获取OC平台发送过来的16进制比特数组格式数据，首先根据比特数组中的功能码（功能码在数据哪个位置，请从通信协议中查看），将不同服务对应的不同数据，根据通信协议将byte类型的属性转换为所需类型，保存到全局变量中，然后调用toJsonNode方法，拼装成一个Json对象并返回。其中mid为消息序号，根据通信协议中是否使用消息序号来决定代码中是否使用。详情请参照文末样例代码。 图3‑10 数据上行解码流程图 打包编解码打包编解码，即将该maven工程打包成jar文件。检查pom.xml中的&lt;packaging&gt;bundle&lt;/packaging&gt;值是否为bundle，不能为jar。以eclipse为例，在工程上右键选择RunAs然后选择Maven build…如图3‑11所示。 图3‑11 Mavenbuild 在Goals中输入clean package点击Run按钮，如图3‑12所示。 图3‑12 Mavenpackage 等待控制台出现BUILDSUCCESS，即可在当前项目的target目录下找到打包好的jar文件，如图3‑13所示，打包编解码完成。 图3‑13 Build 附录 点击显/隐内容 上行代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557package com.thrid.party.codec.demo;import java.util.Arrays;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ArrayNode;import com.fasterxml.jackson.databind.node.ObjectNode;public class ReportProcess &#123;// private String identifier;private String msgType = &quot;deviceReq&quot;;private int hasMore = 0;private int errcode = 0;// 在报文中表示报文类型的字段private byte bFunctionCode;// 开机信息功能码private static final byte DEVICE_POWER_ON = 0x01;// 数据上报功能码private static final byte DEVICE_DATA_REPORT = 0x02;// 应答报文功能码private static final byte DEVICE_REPLY = (byte) 0xAA;// 无后续数据private static final int NO_MORE = 0;private static final String REQUEST =&quot;deviceReq&quot;;private static final String RESPONSE =&quot;deviceRsp&quot;;private int identifier;private int protocolVersion;// 终端类型默认为12private int deviceType;private int iDeviceState = 0;// 终端压力阈值（默认未0），上行数据会对这个值进行覆盖private int distanceAlarmThreshold = 0;;// 终端定时上报时间 ，上行数据会对这个值进行覆盖private int iHeartBeatTime = 0;// 终端报警间隔时间，上行数据会对这个值进行覆盖private int iAlarmReportInterval = 0;private int iSampleInterval = 0;// 终端硬件版本，上行数据会对这个值进行覆盖private int iVersionHW = 1;// 终端软件版本，，上行数据会对这个值进行覆盖private int iVersionFW = 1;// 终端SN号，上行数据会对这个值进行覆盖private int iDeviceSN = 1;private int iNbiotState = 0;// 电池状态，上行数据会对这个值进行覆盖private int iBatteryState = 0;// 云端应答状态，上行数据会对这个值进行覆盖private int iAckState = 0;private int iGuardState = 0;// 报警状态 （默认为0不报警），在定时上报中会对这个值进行覆盖private int iAlarmState = 0;// 当前压力，在定时上报中会对这个值进行覆盖private int iCurPValue = 0;// 当前角度，在定时上报中会对这个值进行覆盖private int iBatteryVoltage = 3600;private int iBatteryCap;// 信号强度，在定时上报中会对这个值进行覆盖private int iSignalStrength = 0;// 信号覆盖等级，在定时上报中会对这个值进行覆盖private int iSignalECL = 0;// 信噪比，在定时上报中会对这个值进行覆盖private int iSignalSNR = 0;// 小区所在Id,在定时上报中会对这个值进行覆盖private int iCellId = 0;// 小区所在得PCI,在定时上报中会对这个值进行覆盖private int iSignalPCI = 0;// 温度，在定时上报中会对这个值进行覆盖// private int iTemperature = 0;// 终端回应设置信息时上发的错误码private int iResult = 0;private int mid = 0;private int curTilt = 0;private int bgTilt = 0;private int gasDensity = 0;private int alarmThreshold = 0;private int waterStatus = 0;private int deviceState = 0;private String strDevPostfix;private String imei;private String imsi;/\*\*\* \@param binaryData 设备发送给平台coap报文\* \@return\*/public ReportProcess(byte[] binaryData) &#123;binaryData = Utilty.getInstance().positionFormat(binaryData);protocolVersion = binaryData[0];bFunctionCode = binaryData[1];identifier = Utilty.getInstance().bytes2Int(binaryData, 2, 2);mid = Utilty.getInstance().bytes2Int(binaryData, 4, 2);Utilty.getInstance().mid = mid;Utilty.getInstance().functioncode = bFunctionCode;System.out.println(&quot;dingmingdong\\n&quot;);System.out.println(Utilty.getInstance().mid);System.out.println(identifier);if (bFunctionCode == DEVICE_POWER_ON) &#123;msgType = REQUEST;hasMore = NO_MORE;iDeviceSN = Utilty.getInstance().bytes2Int(binaryData,8, 4);deviceType = binaryData[12];// iGuardState = binaryData[5];iVersionHW = binaryData[13];iVersionFW = Utilty.getInstance().bytes2Int(binaryData,14, 4);//strDevPostfix = new String(binaryData, 14, 16);//iDeviceState = Utilty.getInstance().bytes2Int(binaryData,30, 2);iHeartBeatTime = Utilty.getInstance().bytes2Int(binaryData, 20, 2);iAlarmReportInterval = Utilty.getInstance().bytes2Int(binaryData, 22, 2);iSampleInterval = Utilty.getInstance().bytes2Int(binaryData, 24, 2);imei = new String(binaryData, 26, 16);imsi = new String(binaryData, 42, 16);alarmThreshold = Utilty.getInstance().bytes2Int(binaryData, 58, 2);//binArray用于存放状态码的二进制数字，由于binaryData[31]转换的二进制数组中目前未携带有用信息，不做解析// int[] binArray = Utilty.getInstance().byte2Binary(binaryData[30]);// iBatteryState = binArray[0];//iAckState = binArray[1];// iNbiotState = binArray[2];// iGuardState = binArray[3];// iAlarmState = binArray[4];// iDeviceState = binArray[5];// iBlueteethState = binArray[6];// strModuleVersion = new String(binaryData, 21, 20);&#125; else if( bFunctionCode == DEVICE_DATA_REPORT )&#123;msgType = REQUEST;hasMore = NO_MORE;iDeviceSN = Utilty.getInstance().bytes2Int(binaryData,8, 4);deviceState = Utilty.getInstance().bytes2Int(binaryData,12, 2);// iBatteryVoltage = Utilty.getInstance().bytes2Int(binaryData, 4, 2);iBatteryCap = Utilty.getInstance().bytes2Int(binaryData, 14, 1);iSignalStrength = Utilty.getInstance().bytes2Int(binaryData, 16, 4);iSignalECL = binaryData[20];iSignalSNR = binaryData[21];iCellId = Utilty.getInstance().bytes2Int(binaryData, 22, 4);iSignalPCI = Utilty.getInstance().bytes2Int(binaryData, 26, 2);bgTilt = Utilty.getInstance().bytes2Int(binaryData, 28, 2);curTilt = Utilty.getInstance().bytes2Int(binaryData, 30, 2);gasDensity = Utilty.getInstance().bytes2Int(binaryData, 32, 2);waterStatus = Utilty.getInstance().bytes2Int(binaryData, 34, 2);&#125;else if (bFunctionCode == DEVICE_REPLY) &#123;msgType = RESPONSE;// 在华为的API中规定 ： errcode 为0表示成功，1表示失败 ；但下位机协议中规定错误码为0无错误，1超范围，2检验错误；在profile文件中终端的应答应当包含一个int型的result参数,// 为了避免数据损失，在这里将终端的错误码放在result中，而errcode按照华为的API规定，只要下位机的错误码不为零，就认为失败，即在error中装入1.errcode = binaryData[8]==0?0:1;iResult = binaryData[8];&#125; else &#123;return;&#125;&#125;public ObjectNode toJsonNode() &#123;try &#123;//组装body体ObjectMapper mapper = new ObjectMapper();ObjectNode root = mapper.createObjectNode();String s = Integer.toString(this.identifier);root.put(&quot;identifier&quot;, s);System.out.println(s);root.put(&quot;msgType&quot;, this.msgType);//根据msgType字段组装消息体if (this.msgType.equals(REQUEST) &amp;&amp; bFunctionCode == DEVICE_POWER_ON) &#123;root.put(&quot;hasMore&quot;, this.hasMore);ArrayNode arrynode = mapper.createArrayNode();// serviceId = Basic 数据组装ObjectNode BasicNode = mapper.createObjectNode();BasicNode.put(&quot;serviceId&quot;, &quot;Basic&quot;);ObjectNode BasicData = mapper.createObjectNode();BasicData.put(&quot;heartBeatTime&quot;, this.iHeartBeatTime);BasicData.put(&quot;alarmReportInterval&quot;, this.iAlarmReportInterval);BasicData.put(&quot;sampleInterval&quot;, this.iSampleInterval);BasicData.put(&quot;mid&quot;, this.mid);//hydrantBasicData.put(&quot;tiltAlarmThreshold&quot;, this.iTiltAlarmThreshold);BasicNode.put(&quot;serviceData&quot;,BasicData);arrynode.add(BasicNode);// serviceId = Tilt 数据组装ObjectNode TiltNode = mapper.createObjectNode();TiltNode.put(&quot;serviceId&quot;, &quot;Tilt&quot;);ObjectNode TiltData = mapper.createObjectNode();TiltData.put(&quot;alarmThreshold&quot;, this.alarmThreshold);//hydrantBasicData.put(&quot;tiltAlarmThreshold&quot;, this.iTiltAlarmThreshold);TiltNode.put(&quot;serviceData&quot;,TiltData);arrynode.add(TiltNode);// serviceId = DeviceInfo 数据组装ObjectNode deviceInfoNode = mapper.createObjectNode();deviceInfoNode.put(&quot;serviceId&quot;, &quot;DeviceInfo&quot;);ObjectNode deviceInfoData = mapper.createObjectNode();deviceInfoData.put(&quot;deviceType&quot;, this.deviceType);deviceInfoData.put(&quot;versionHW&quot;, this.iVersionHW);deviceInfoData.put(&quot;versionFW&quot;, this.iVersionFW);deviceInfoData.put(&quot;deviceSN&quot;, this.iDeviceSN);deviceInfoData.put(&quot;imei&quot;, this.imei);deviceInfoData.put(&quot;imsi&quot;, this.imsi);deviceInfoData.put(&quot;deviceID&quot;, this.identifier);deviceInfoData.put(&quot;protocolVersion&quot;, this.protocolVersion);//deviceInfoData.put(&quot;moduleVersion&quot;, this.strModuleVersion);deviceInfoNode.put(&quot;serviceData&quot;,deviceInfoData);arrynode.add(deviceInfoNode);root.put(&quot;data&quot;, arrynode);&#125; else if(this.msgType.equals(REQUEST) &amp;&amp; bFunctionCode == DEVICE_DATA_REPORT)&#123;root.put(&quot;hasMore&quot;, this.hasMore);ArrayNode arrynode = mapper.createArrayNode();// serviceId = Basic 数据组装ObjectNode BasicNode = mapper.createObjectNode();BasicNode.put(&quot;serviceId&quot;, &quot;Basic&quot;);ObjectNode BasicData = mapper.createObjectNode();//BasicData.put(&quot;batteryVoltage&quot;, this.iBatteryVoltage);BasicData.put(&quot;batteryLevel&quot;,this.iBatteryCap);BasicData.put(&quot;deviceState&quot;, this.deviceState);BasicData.put(&quot;mid&quot;, this.mid);BasicNode.put(&quot;serviceData&quot;,BasicData);arrynode.add(BasicNode);// serviceId = Connectivity 数据组装ObjectNode connectivityNode = mapper.createObjectNode();ObjectNode connectivityData = mapper.createObjectNode();connectivityData.put(&quot;signalStrength&quot;, this.iSignalStrength);connectivityData.put(&quot;cellId&quot;, this.iCellId);connectivityData.put(&quot;signalECL&quot;, this.iSignalECL);connectivityData.put(&quot;signalPCI&quot;, this.iSignalPCI);connectivityData.put(&quot;signalSNR&quot;, this.iSignalSNR);connectivityNode.put(&quot;serviceId&quot;, &quot;Connectivity&quot;);connectivityNode.put(&quot;serviceData&quot;,connectivityData);arrynode.add(connectivityNode);// serviceId = Tilt 数据组装ObjectNode tiltNode = mapper.createObjectNode();ObjectNode tiltData = mapper.createObjectNode();tiltData.put(&quot;curTilt&quot;, this.curTilt);tiltData.put(&quot;bgTilt&quot;, this.bgTilt);tiltData.put(&quot;gasDensity&quot;, this.gasDensity);tiltData.put(&quot;waterStatus&quot;, this.waterStatus);tiltNode.put(&quot;serviceId&quot;, &quot;Tilt&quot;);tiltNode.put(&quot;serviceData&quot;,tiltData);arrynode.add(tiltNode);// serviceId = DeviceInfo 数据组装ObjectNode deviceInfoNode = mapper.createObjectNode();deviceInfoNode.put(&quot;serviceId&quot;, &quot;DeviceInfo&quot;);ObjectNode deviceInfoData = mapper.createObjectNode();// deviceInfoData.put(&quot;deviceType&quot;, this.deviceType);// deviceInfoData.put(&quot;versionHW&quot;, this.iVersionHW);// deviceInfoData.put(&quot;versionFW&quot;, this.iVersionFW);deviceInfoData.put(&quot;deviceSN&quot;, this.iDeviceSN);// deviceInfoData.put(&quot;imei&quot;, this.imei);// deviceInfoData.put(&quot;imsi&quot;, this.imsi);deviceInfoData.put(&quot;deviceID&quot;, this.identifier);deviceInfoData.put(&quot;protocolVersion&quot;, this.protocolVersion);//deviceInfoData.put(&quot;moduleVersion&quot;, this.strModuleVersion);deviceInfoNode.put(&quot;serviceData&quot;,deviceInfoData);arrynode.add(deviceInfoNode);// serviceId = DeviceState 数据组装// ObjectNode deviceStateNode = mapper.createObjectNode();// ObjectNode deviceStateData = mapper.createObjectNode();//deviceStateData.put(&quot;guardState&quot;, this.iGuardState);//deviceStateData.put(&quot;alarmState&quot;, this.iAlarmState);//deviceStateData.put(&quot;moduleState&quot;, this.iNbiotState);//deviceStateData.put(&quot;batteryState&quot;, this.iBatteryState);//deviceStateData.put(&quot;ackState&quot;, this.iAckState);//deviceStateNode.put(&quot;serviceId&quot;, &quot;DeviceState&quot;);//deviceStateNode.put(&quot;serviceData&quot;,deviceStateData);//arrynode.add(deviceStateNode);// serviceId = Temperature 数据组装// ObjectNode temperatureNode = mapper.createObjectNode();// ObjectNode temperatureData = mapper.createObjectNode();// temperatureData.put(&quot;temperature&quot;, this.iTemperature);// temperatureNode.put(&quot;serviceId&quot;, &quot;Temperature&quot;);// temperatureNode.put(&quot;serviceData&quot;,temperatureData);// arrynode.add(temperatureNode);root.put(&quot;data&quot;, arrynode);&#125;else &#123;root.put(&quot;mid&quot;, this.mid);root.put(&quot;errcode&quot;, this.errcode);//组装body体，只能为ObjectNode对象ObjectNode body = mapper.createObjectNode();body.put(&quot;result&quot;, iResult);root.put(&quot;body&quot;, body);&#125;return root;&#125; catch (Exception e) &#123;e.printStackTrace();return null;&#125;&#125;&#125; 下行数据代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725package com.thrid.party.codec.demo;import java.util.Arrays;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.node.ObjectNode;public class CmdProcess &#123;private String identifier = &quot;0&quot;;private int intIdentifier = 0;private String msgType = &quot;deviceReq&quot;;private String serviceId = &quot;Brightness&quot;;private int hasMore = 0;private static int mid = 0;private int errcode = 0;private JsonNode paras;private String cmd = &quot;REREAD&quot;;// 云端回应private static final byte B_CMD_RESPONSE = (byte) 0xAA;// 配置信息private static final byte B_TO_CONFIGURATION = 0x03;// 复位命令private static final byte B_TO_RESET = 0x04;// 布防/撤防private static final byte B_TO_GUARD_OR_WITHDRAW = 0x05;// 忽略本次报警private static final byte B_TO_IGNORE = 0x06;// 重新读取开机信息private static final byte B_TO_REREAD = 0x07;private static final byte B_TO_FACTORYDEFAULT = 0x09;private static final byte B_TO_SAMPLE_BGTILT_RSP = 10;// 在报文中表示报文类型的字段private byte bFunctionCode;// 在报文中表示信息长度的字段private byte dataLength;// 将要配置的新IDprivate int iNewId;// 上报时间private int iHeartBeatTime;// 报警间隔private int iAlarmReportInterval;private int iSampleInterval;private byte protocolVersion = 1;// IP设置private int iAddressIP;// 端口号设置private int iAddressPort;// 压力报警阈值private int distanceAlarmThreshold;private int reportmid;private int iPressureAlarmLowThreshold;private int iPressureAlarmUpDiff;private int iPressureAlarmLowDiff;// 倾斜角报警阈值// private int iTiltAlarmThreshold;// 在命令为GUARD_OR_WITHDRAW时是要布防还是撤防： 1表示布防，0表示撤防private byte bGuardOrWithdraw = 1;// 用于存储平台自动应答时返回的request字段，该字段即设备的上行数据byte[] deviceRequest;public CmdProcess() &#123;&#125;public CmdProcess(ObjectNode input) &#123;try &#123;try &#123;this.identifier = input.get(&quot;identifier&quot;).asText();&#125; catch (Exception e) &#123;&#125;mid = mid + 1;this.msgType = input.get(&quot;msgType&quot;).asText();// this.mid = input.get(&quot;mid&quot;).asInt();//未使用mid在此处不能放出来，否则会造成程序异常if (msgType.equals(&quot;cloudRsp&quot;)) &#123;this.errcode = input.get(&quot;errcode&quot;).asInt();deviceRequest = input.get(&quot;request&quot;).binaryValue();byte[] identifierBytes = &#123;deviceRequest[3],deviceRequest[2]&#125;;intIdentifier = Utilty.getInstance().bytes2Int(identifierBytes, 0, 2);byte[] midBytes = &#123;deviceRequest[5],deviceRequest[4]&#125;;reportmid = Utilty.getInstance().bytes2Int(midBytes, 0, 2);bFunctionCode = B_CMD_RESPONSE;dataLength = 0x01;&#125; else &#123;this.cmd = input.get(&quot;cmd&quot;).asText();switch (this.cmd) &#123;case &quot;CONFIGURATION&quot;:bFunctionCode = B_TO_CONFIGURATION;dataLength = 22;this.paras = input.get(&quot;paras&quot;);iNewId = this.paras.get(&quot;newId&quot;).asInt();iHeartBeatTime = this.paras.get(&quot;heartBeatTime&quot;).asInt();iAlarmReportInterval = this.paras.get(&quot;alarmReportInterval&quot;).asInt();iSampleInterval = this.paras.get(&quot;sampleInterval&quot;).asInt();iAddressIP = this.paras.get(&quot;addressIP&quot;).asInt();iAddressPort = this.paras.get(&quot;addressPort&quot;).asInt();distanceAlarmThreshold = this.paras.get(&quot;distanceAlarmThreshold&quot;).asInt();//iPressureAlarmLowThreshold =this.paras.get(&quot;pressureAlarmLowThreshold&quot;).asInt();//iPressureAlarmUpDiff = this.paras.get(&quot;pressureAlarmUpDiff&quot;).asInt();//iPressureAlarmLowDiff = this.paras.get(&quot;pressureAlarmLowDiff&quot;).asInt();//iTiltAlarmThreshold = this.paras.get(&quot;tiltAlarmThreshold&quot;).asInt();break;case &quot;RESET&quot;:bFunctionCode = B_TO_RESET;dataLength = 0x00;break;case &quot;SAMPLE_BGTILT_RSP&quot;:bFunctionCode = B_TO_SAMPLE_BGTILT_RSP;dataLength = 0x00;break;case &quot;GUARD_OR_WITHDRAW&quot;:bFunctionCode = B_TO_GUARD_OR_WITHDRAW;dataLength = 0x01;this.paras = input.get(&quot;paras&quot;);bGuardOrWithdraw = (byte) this.paras.get(&quot;guardOrWithdraw&quot;).asInt();break;case &quot;IGNORE&quot;:bFunctionCode = B_TO_IGNORE;dataLength = 0x00;break;case &quot;REREAD&quot;:bFunctionCode = B_TO_REREAD;dataLength = 0x00;break;case &quot;FACTORYDEFAULT&quot;:bFunctionCode = B_TO_FACTORYDEFAULT;dataLength = 0x00;break;default:break;&#125;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;public byte[] toByte() &#123;try &#123;if (this.msgType.equals(&quot;cloudReq&quot;)) &#123;byte[] bytesRead = null;int idid = 0;try &#123;idid = Integer.parseInt(this.identifier);&#125; catch (NumberFormatException e) &#123;e.printStackTrace();&#125;switch (this.cmd) &#123;case &quot;CONFIGURATION&quot;:&#123;//iNewId = this.paras.get(&quot;newId&quot;).asInt();//iHeartBeatTime = this.paras.get(&quot;heartBeatTime&quot;).asInt();//iAlarmReportInterval = this.paras.get(&quot;alarmReportInterval&quot;).asInt();//iAddressIP = this.paras.get(&quot;addressIP&quot;).asInt();//iAddressPort = this.paras.get(&quot;addressPort&quot;).asInt();//iPressureAlarmThreshold = this.paras.get(&quot;pressureAlarmThreshold&quot;).asInt();//iTiltAlarmThreshold = this.paras.get(&quot;tiltAlarmThreshold&quot;).asInt();dataLength = 18;bytesRead= new byte[28];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;//byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNewId = Utilty.getInstance().int2Bytes(this.iNewId, 2);bytesRead[8] = bytesNewId[1];bytesRead[9] = bytesNewId[0];byte[] bytesHeartBeatTime = Utilty.getInstance().int2Bytes(this.iHeartBeatTime,2);bytesRead[10] = bytesHeartBeatTime[1];bytesRead[11] = bytesHeartBeatTime[0];byte[] bytesAlarmReportInterval =Utilty.getInstance().int2Bytes(this.iAlarmReportInterval, 2);bytesRead[12] = bytesAlarmReportInterval[1];bytesRead[13] = bytesAlarmReportInterval[0];byte[] bytesSampleInterval =Utilty.getInstance().int2Bytes(this.iSampleInterval, 2);bytesRead[14] = bytesSampleInterval[1];bytesRead[15] = bytesSampleInterval[0];byte[] bytesAddressIP = Utilty.getInstance().int2Bytes(this.iAddressIP, 4);bytesRead[16] = bytesAddressIP[3];bytesRead[17] = bytesAddressIP[2];bytesRead[18] = bytesAddressIP[1];bytesRead[19] = bytesAddressIP[0];byte[] bytesAddressPort = Utilty.getInstance().int2Bytes(this.iAddressPort, 2);bytesRead[20] = bytesAddressPort[1];bytesRead[21] = bytesAddressPort[0];byte[] bytesAlarmThreshold =Utilty.getInstance().int2Bytes(this.distanceAlarmThreshold, 2);bytesRead[22] = bytesAlarmThreshold[1];bytesRead[23] = bytesAlarmThreshold[0];bytesRead[24] = 0;bytesRead[25] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[26] = bytesCRC[1];bytesRead[27] = bytesCRC[0];break;&#125;case &quot;RESET&quot;:&#123;bFunctionCode = B_TO_RESET;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;GUARD_OR_WITHDRAW&quot;:&#123;bFunctionCode = B_TO_GUARD_OR_WITHDRAW;bGuardOrWithdraw = (byte) this.paras.get(&quot;guardOrWithdraw&quot;).asInt();dataLength = 0x02;bytesRead= new byte[12];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;bytesRead[8] = bGuardOrWithdraw;bytesRead[9] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[10] = bytesCRC[1];bytesRead[11] = bytesCRC[0];break;&#125;case &quot;IGNORE&quot;:&#123;bFunctionCode = B_TO_IGNORE;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;SAMPLE_BGTILT_RSP&quot;:&#123;bFunctionCode = B_TO_SAMPLE_BGTILT_RSP;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;FACTORYDEFAULT&quot;:&#123;bFunctionCode = B_TO_FACTORYDEFAULT;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;case &quot;REREAD&quot;:&#123;bFunctionCode = B_TO_REREAD;dataLength = 0x00;bytesRead= new byte[10];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = bFunctionCode;byte[] bytesId = Utilty.getInstance().str2Bytes(this.identifier);bytesRead[2] = (byte) (idid &amp; 0xFF);bytesRead[3] = (byte) (idid \&gt;\&gt; 8);byte[] bytesmid = Utilty.getInstance().int2Bytes(CmdProcess.mid, 2);bytesRead[4] = bytesmid[1];bytesRead[5] = bytesmid[0];bytesRead[6] = dataLength;bytesRead[7] = 0;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[8] = bytesCRC[1];bytesRead[9] = bytesCRC[0];break;&#125;default:break;&#125;return bytesRead;&#125; else if (this.msgType.equals(&quot;cloudRsp&quot;)) &#123;byte[] bytesRead = new byte[12];/\*\*平台对上行数据的自动应答过程中，并不会每次都去调用带参的构造方法（猜测），所以数据的具体组装需要在toByte方法中进行以保证回复及下发的稳定性\*/bFunctionCode = B_CMD_RESPONSE;dataLength = 2;/\*\*在此对捕获的设备命令进行校验，如果无错误，将errcode置为0，若校验错误，将其置为2\*/boolean isValide = false;if(deviceRequest != null)&#123;isValide = Utilty.getInstance().isValid(deviceRequest);&#125;bytesRead= new byte[12];bytesRead[0] = (byte)protocolVersion;bytesRead[1] = B_CMD_RESPONSE;//byte[] bytesId = Utilty.getInstance().int2Bytes(this.intIdentifier, 2);;bytesRead[2] = deviceRequest[2];bytesRead[3] = deviceRequest[3];//byte[] bytesmid = Utilty.getInstance().int2Bytes(this.reportmid, 2);bytesRead[4] = deviceRequest[4];bytesRead[5] = deviceRequest[5];bytesRead[6] = dataLength;bytesRead[7] = 0;bytesRead[8] = 0;//(byte) (isValide?0:2);bytesRead[9] = (byte)Utilty.getInstance().functioncode;byte[] bytesNoCRC = Arrays.copyOf(bytesRead, bytesRead.length - 2);byte[] bytesCRC = Utilty.getInstance().CRC16(bytesNoCRC);bytesRead[10] = bytesCRC[1];bytesRead[11] = bytesCRC[0];return bytesRead;&#125;return null;&#125; catch (Exception e) &#123;// TODO: handle exceptione.printStackTrace();return null;&#125;&#125;&#125;]]></content>
      <categories>
        <category>Iot</category>
      </categories>
      <tags>
        <tag>OceanConnect</tag>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty组件和设计]]></title>
    <url>%2FNetty%2FNetty%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Netty的组件和设计Channel 接口 在基于Java的网络编程中，其基本的构造是class socket。Netty的Channel接口所提供的api，大大的降低了直接使用Socket类的复杂性。 EventLoop 接口 EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。 一个EventLoopGroup包含一个或者多个EventLoop； 一个EventLoop在它的生命周期内只和一个Thread绑定； 所有由EventLoop处理的 I/O 事件都将在它专有的Thread上被处理； 一个Channel在它的生命周期内只注册于一个EventLoop； 一个EventLoop可能会被分配给一个或多个Channel。 ChannelFuture 接口 Netty 中所有的 I/O 操作都是异步的。因为一个操作可能不会 立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了 ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以 便在某个操作完成时（无论是否成功）得到通知。 ChannelHandler 接口 充当了所有 处理入站和出站数据的应用程序逻辑的容器。 ChannelPipeline 接口 ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站 和出站事件流的 API。当 Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。 ChannelPipeline中存放的是ChannelHandler链，一条数据可以经过多个ChannelHandler进行处理，类似拦截器。 引导 Bootstrap 客户端配置 ServerBootstrap 服务端配置 引导一个客户端只需要一个 EventLoopGroup，但是一个 ServerBootstrap则需要两个（也可以是同一个实例）。 因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务 器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传 入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
